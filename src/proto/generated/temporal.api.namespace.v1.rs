// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespaceInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "super::super::enums::v1::NamespaceState", tag = "2")]
    pub state: i32,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub owner_email: ::prost::alloc::string::String,
    /// A key-value map for any customized purpose.
    #[prost(map = "string, string", tag = "5")]
    pub data: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "6")]
    pub id: ::prost::alloc::string::String,
    /// All capabilities the namespace supports.
    #[prost(message, optional, tag = "7")]
    pub capabilities: ::core::option::Option<namespace_info::Capabilities>,
    /// Namespace configured limits
    #[prost(message, optional, tag = "8")]
    pub limits: ::core::option::Option<namespace_info::Limits>,
    /// Whether scheduled workflows are supported on this namespace. This is only needed
    /// temporarily while the feature is experimental, so we can give it a high tag.
    #[prost(bool, tag = "100")]
    pub supports_schedules: bool,
}
/// Nested message and enum types in `NamespaceInfo`.
pub mod namespace_info {
    /// Namespace capability details. Should contain what features are enabled in a namespace.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Capabilities {
        /// True if the namespace supports eager workflow start.
        #[prost(bool, tag = "1")]
        pub eager_workflow_start: bool,
        /// True if the namespace supports sync update
        #[prost(bool, tag = "2")]
        pub sync_update: bool,
        /// True if the namespace supports async update
        #[prost(bool, tag = "3")]
        pub async_update: bool,
        /// True if the namespace supports worker heartbeats
        #[prost(bool, tag = "4")]
        pub worker_heartbeats: bool,
        /// True if the namespace supports reported problems search attribute
        #[prost(bool, tag = "5")]
        pub reported_problems_search_attribute: bool,
        /// True if the namespace supports pausing workflows
        #[prost(bool, tag = "6")]
        pub workflow_pause: bool,
        /// True if the namespace supports standalone activities
        #[prost(bool, tag = "7")]
        pub standalone_activities: bool,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Limits {
        /// Maximum size in bytes for payload fields in workflow history events
        /// (e.g., workflow/activity inputs and results, failure details, signal payloads).
        /// When exceeded, the server will reject the operation with an error.
        #[prost(int64, tag = "1")]
        pub blob_size_limit_error: i64,
        /// Maximum total memo size in bytes per workflow execution.
        #[prost(int64, tag = "2")]
        pub memo_size_limit_error: i64,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespaceConfig {
    #[prost(message, optional, tag = "1")]
    pub workflow_execution_retention_ttl: ::core::option::Option<
        ::prost_types::Duration,
    >,
    #[prost(message, optional, tag = "2")]
    pub bad_binaries: ::core::option::Option<BadBinaries>,
    /// If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
    #[prost(enumeration = "super::super::enums::v1::ArchivalState", tag = "3")]
    pub history_archival_state: i32,
    #[prost(string, tag = "4")]
    pub history_archival_uri: ::prost::alloc::string::String,
    /// If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
    #[prost(enumeration = "super::super::enums::v1::ArchivalState", tag = "5")]
    pub visibility_archival_state: i32,
    #[prost(string, tag = "6")]
    pub visibility_archival_uri: ::prost::alloc::string::String,
    /// Map from field name to alias.
    #[prost(map = "string, string", tag = "7")]
    pub custom_search_attribute_aliases: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadBinaries {
    #[prost(map = "string, message", tag = "1")]
    pub binaries: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        BadBinaryInfo,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadBinaryInfo {
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub operator: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNamespaceInfo {
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub owner_email: ::prost::alloc::string::String,
    /// A key-value map for any customized purpose.
    /// If data already exists on the namespace,
    /// this will merge with the existing key values.
    #[prost(map = "string, string", tag = "3")]
    pub data: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// New namespace state, server will reject if transition is not allowed.
    /// Allowed transitions are:
    ///   Registered -> \[ Deleted | Deprecated | Handover \]
    ///   Handover -> \[ Registered \]
    /// Default is NAMESPACE_STATE_UNSPECIFIED which is do not change state.
    #[prost(enumeration = "super::super::enums::v1::NamespaceState", tag = "4")]
    pub state: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NamespaceFilter {
    /// By default namespaces in NAMESPACE_STATE_DELETED state are not included.
    /// Setting include_deleted to true will include deleted namespaces.
    /// Note: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.
    #[prost(bool, tag = "1")]
    pub include_deleted: bool,
}
