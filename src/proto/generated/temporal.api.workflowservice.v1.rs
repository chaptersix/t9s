// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterNamespaceRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub owner_email: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub workflow_execution_retention_period: ::core::option::Option<
        ::prost_types::Duration,
    >,
    #[prost(message, repeated, tag = "5")]
    pub clusters: ::prost::alloc::vec::Vec<
        super::super::replication::v1::ClusterReplicationConfig,
    >,
    #[prost(string, tag = "6")]
    pub active_cluster_name: ::prost::alloc::string::String,
    /// A key-value map for any customized purpose.
    #[prost(map = "string, string", tag = "7")]
    pub data: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "8")]
    pub security_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "9")]
    pub is_global_namespace: bool,
    /// If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
    #[prost(enumeration = "super::super::enums::v1::ArchivalState", tag = "10")]
    pub history_archival_state: i32,
    #[prost(string, tag = "11")]
    pub history_archival_uri: ::prost::alloc::string::String,
    /// If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
    #[prost(enumeration = "super::super::enums::v1::ArchivalState", tag = "12")]
    pub visibility_archival_state: i32,
    #[prost(string, tag = "13")]
    pub visibility_archival_uri: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegisterNamespaceResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNamespacesRequest {
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub namespace_filter: ::core::option::Option<
        super::super::namespace::v1::NamespaceFilter,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNamespacesResponse {
    #[prost(message, repeated, tag = "1")]
    pub namespaces: ::prost::alloc::vec::Vec<DescribeNamespaceResponse>,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeNamespaceRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeNamespaceResponse {
    #[prost(message, optional, tag = "1")]
    pub namespace_info: ::core::option::Option<
        super::super::namespace::v1::NamespaceInfo,
    >,
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<super::super::namespace::v1::NamespaceConfig>,
    #[prost(message, optional, tag = "3")]
    pub replication_config: ::core::option::Option<
        super::super::replication::v1::NamespaceReplicationConfig,
    >,
    #[prost(int64, tag = "4")]
    pub failover_version: i64,
    #[prost(bool, tag = "5")]
    pub is_global_namespace: bool,
    /// Contains the historical state of failover_versions for the cluster, truncated to contain only the last N
    /// states to ensure that the list does not grow unbounded.
    #[prost(message, repeated, tag = "6")]
    pub failover_history: ::prost::alloc::vec::Vec<
        super::super::replication::v1::FailoverStatus,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNamespaceRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub update_info: ::core::option::Option<
        super::super::namespace::v1::UpdateNamespaceInfo,
    >,
    #[prost(message, optional, tag = "3")]
    pub config: ::core::option::Option<super::super::namespace::v1::NamespaceConfig>,
    #[prost(message, optional, tag = "4")]
    pub replication_config: ::core::option::Option<
        super::super::replication::v1::NamespaceReplicationConfig,
    >,
    #[prost(string, tag = "5")]
    pub security_token: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub delete_bad_binary: ::prost::alloc::string::String,
    /// promote local namespace to global namespace. Ignored if namespace is already global namespace.
    #[prost(bool, tag = "7")]
    pub promote_namespace: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNamespaceResponse {
    #[prost(message, optional, tag = "1")]
    pub namespace_info: ::core::option::Option<
        super::super::namespace::v1::NamespaceInfo,
    >,
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<super::super::namespace::v1::NamespaceConfig>,
    #[prost(message, optional, tag = "3")]
    pub replication_config: ::core::option::Option<
        super::super::replication::v1::NamespaceReplicationConfig,
    >,
    #[prost(int64, tag = "4")]
    pub failover_version: i64,
    #[prost(bool, tag = "5")]
    pub is_global_namespace: bool,
}
/// Deprecated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeprecateNamespaceRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub security_token: ::prost::alloc::string::String,
}
/// Deprecated.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeprecateNamespaceResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<super::super::common::v1::WorkflowType>,
    #[prost(message, optional, tag = "4")]
    pub task_queue: ::core::option::Option<super::super::taskqueue::v1::TaskQueue>,
    /// Serialized arguments to the workflow. These are passed as arguments to the workflow function.
    #[prost(message, optional, tag = "5")]
    pub input: ::core::option::Option<super::super::common::v1::Payloads>,
    /// Total workflow execution timeout including retries and continue as new.
    #[prost(message, optional, tag = "6")]
    pub workflow_execution_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Timeout of a single workflow run.
    #[prost(message, optional, tag = "7")]
    pub workflow_run_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Timeout of a single workflow task.
    #[prost(message, optional, tag = "8")]
    pub workflow_task_timeout: ::core::option::Option<::prost_types::Duration>,
    /// The identity of the client who initiated this request
    #[prost(string, tag = "9")]
    pub identity: ::prost::alloc::string::String,
    /// A unique identifier for this start request. Typically UUIDv4.
    #[prost(string, tag = "10")]
    pub request_id: ::prost::alloc::string::String,
    /// Defines whether to allow re-using the workflow id from a previously *closed* workflow.
    /// The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    ///
    /// See `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow.
    #[prost(enumeration = "super::super::enums::v1::WorkflowIdReusePolicy", tag = "11")]
    pub workflow_id_reuse_policy: i32,
    /// Defines how to resolve a workflow id conflict with a *running* workflow.
    /// The default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.
    ///
    /// See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
    #[prost(
        enumeration = "super::super::enums::v1::WorkflowIdConflictPolicy",
        tag = "22"
    )]
    pub workflow_id_conflict_policy: i32,
    /// The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
    #[prost(message, optional, tag = "12")]
    pub retry_policy: ::core::option::Option<super::super::common::v1::RetryPolicy>,
    /// See <https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/>
    #[prost(string, tag = "13")]
    pub cron_schedule: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "14")]
    pub memo: ::core::option::Option<super::super::common::v1::Memo>,
    #[prost(message, optional, tag = "15")]
    pub search_attributes: ::core::option::Option<
        super::super::common::v1::SearchAttributes,
    >,
    #[prost(message, optional, tag = "16")]
    pub header: ::core::option::Option<super::super::common::v1::Header>,
    /// Request to get the first workflow task inline in the response bypassing matching service and worker polling.
    /// If set to `true` the caller is expected to have a worker available and capable of processing the task.
    /// The returned task will be marked as started and is expected to be completed by the specified
    /// `workflow_task_timeout`.
    #[prost(bool, tag = "17")]
    pub request_eager_execution: bool,
    /// These values will be available as ContinuedFailure and LastCompletionResult in the
    /// WorkflowExecutionStarted event and through SDKs. The are currently only used by the
    /// server itself (for the schedules feature) and are not intended to be exposed in
    /// StartWorkflowExecution.
    #[prost(message, optional, tag = "18")]
    pub continued_failure: ::core::option::Option<super::super::failure::v1::Failure>,
    #[prost(message, optional, tag = "19")]
    pub last_completion_result: ::core::option::Option<
        super::super::common::v1::Payloads,
    >,
    /// Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
    /// If the workflow gets a signal before the delay, a workflow task will be dispatched and the rest
    /// of the delay will be ignored.
    #[prost(message, optional, tag = "20")]
    pub workflow_start_delay: ::core::option::Option<::prost_types::Duration>,
    /// Callbacks to be called by the server when this workflow reaches a terminal state.
    /// If the workflow continues-as-new, these callbacks will be carried over to the new execution.
    /// Callback addresses must be whitelisted in the server's dynamic configuration.
    #[prost(message, repeated, tag = "21")]
    pub completion_callbacks: ::prost::alloc::vec::Vec<
        super::super::common::v1::Callback,
    >,
    /// Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo
    /// for use by user interfaces to display the fixed as-of-start summary and details of the
    /// workflow.
    #[prost(message, optional, tag = "23")]
    pub user_metadata: ::core::option::Option<super::super::sdk::v1::UserMetadata>,
    /// Links to be associated with the workflow.
    #[prost(message, repeated, tag = "24")]
    pub links: ::prost::alloc::vec::Vec<super::super::common::v1::Link>,
    /// If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
    /// To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
    #[prost(message, optional, tag = "25")]
    pub versioning_override: ::core::option::Option<
        super::super::workflow::v1::VersioningOverride,
    >,
    /// Defines actions to be done to the existing running workflow when the conflict policy
    /// WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING is used. If not set (ie., nil value) or set to a
    /// empty object (ie., all options with default value), it won't do anything to the existing
    /// running workflow. If set, it will add a history event to the running workflow.
    #[prost(message, optional, tag = "26")]
    pub on_conflict_options: ::core::option::Option<
        super::super::workflow::v1::OnConflictOptions,
    >,
    /// Priority metadata
    #[prost(message, optional, tag = "27")]
    pub priority: ::core::option::Option<super::super::common::v1::Priority>,
    /// Deployment Options of the worker who will process the eager task. Passed when `request_eager_execution=true`.
    #[prost(message, optional, tag = "28")]
    pub eager_worker_deployment_options: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentOptions,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartWorkflowExecutionResponse {
    /// The run id of the workflow that was started - or used (via WorkflowIdConflictPolicy USE_EXISTING).
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
    /// If true, a new workflow was started.
    #[prost(bool, tag = "3")]
    pub started: bool,
    /// Current execution status of the workflow. Typically remains WORKFLOW_EXECUTION_STATUS_RUNNING
    /// unless a de-dupe occurs or in specific scenarios handled within the ExecuteMultiOperation (refer to its docs).
    #[prost(enumeration = "super::super::enums::v1::WorkflowExecutionStatus", tag = "5")]
    pub status: i32,
    /// When `request_eager_execution` is set on the `StartWorkflowExecutionRequest`, the server - if supported - will
    /// return the first workflow task to be eagerly executed.
    /// The caller is expected to have a worker available to process the task.
    #[prost(message, optional, tag = "2")]
    pub eager_workflow_task: ::core::option::Option<PollWorkflowTaskQueueResponse>,
    /// Link to the workflow event.
    #[prost(message, optional, tag = "4")]
    pub link: ::core::option::Option<super::super::common::v1::Link>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkflowExecutionHistoryRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub execution: ::core::option::Option<super::super::common::v1::WorkflowExecution>,
    #[prost(int32, tag = "3")]
    pub maximum_page_size: i32,
    /// If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of
    /// these, it should be passed here to fetch the next page.
    #[prost(bytes = "vec", tag = "4")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    /// If set to true, the RPC call will not resolve until there is a new event which matches
    /// the `history_event_filter_type`, or a timeout is hit.
    #[prost(bool, tag = "5")]
    pub wait_new_event: bool,
    /// Filter returned events such that they match the specified filter type.
    /// Default: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.
    #[prost(enumeration = "super::super::enums::v1::HistoryEventFilterType", tag = "6")]
    pub history_event_filter_type: i32,
    #[prost(bool, tag = "7")]
    pub skip_archival: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkflowExecutionHistoryResponse {
    #[prost(message, optional, tag = "1")]
    pub history: ::core::option::Option<super::super::history::v1::History>,
    /// Raw history is an alternate representation of history that may be returned if configured on
    /// the frontend. This is not supported by all SDKs. Either this or `history` will be set.
    #[prost(message, repeated, tag = "2")]
    pub raw_history: ::prost::alloc::vec::Vec<super::super::common::v1::DataBlob>,
    /// Will be set if there are more history events than were included in this response
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "4")]
    pub archived: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkflowExecutionHistoryReverseRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub execution: ::core::option::Option<super::super::common::v1::WorkflowExecution>,
    #[prost(int32, tag = "3")]
    pub maximum_page_size: i32,
    #[prost(bytes = "vec", tag = "4")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkflowExecutionHistoryReverseResponse {
    #[prost(message, optional, tag = "1")]
    pub history: ::core::option::Option<super::super::history::v1::History>,
    /// Will be set if there are more history events than were included in this response
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollWorkflowTaskQueueRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub task_queue: ::core::option::Option<super::super::taskqueue::v1::TaskQueue>,
    /// The identity of the worker/client who is polling this task queue
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    /// A unique key for this worker instance, used for tracking worker lifecycle.
    /// This is guaranteed to be unique, whereas identity is not guaranteed to be unique.
    #[prost(string, tag = "7")]
    pub worker_instance_key: ::prost::alloc::string::String,
    /// Deprecated. Use deployment_options instead.
    /// Each worker process should provide an ID unique to the specific set of code it is running
    /// "checksum" in this field name isn't very accurate, it should be though of as an id.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub binary_checksum: ::prost::alloc::string::String,
    /// Deprecated. Use deployment_options instead.
    /// Information about this worker's build identifier and if it is choosing to use the versioning
    /// feature. See the `WorkerVersionCapabilities` docstring for more.
    #[deprecated]
    #[prost(message, optional, tag = "5")]
    pub worker_version_capabilities: ::core::option::Option<
        super::super::common::v1::WorkerVersionCapabilities,
    >,
    /// Worker deployment options that user has set in the worker.
    /// Experimental. Worker Deployments are experimental and might significantly change in the future.
    #[prost(message, optional, tag = "6")]
    pub deployment_options: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentOptions,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollWorkflowTaskQueueResponse {
    /// A unique identifier for this task
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<
        super::super::common::v1::WorkflowExecution,
    >,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<super::super::common::v1::WorkflowType>,
    /// The last workflow task started event which was processed by some worker for this execution.
    /// Will be zero if no task has ever started.
    #[prost(int64, tag = "4")]
    pub previous_started_event_id: i64,
    /// The id of the most recent workflow task started event, which will have been generated as a
    /// result of this poll request being served. Will be zero if the task
    /// does not contain any events which would advance history (no new WFT started).
    /// Currently this can happen for queries.
    #[prost(int64, tag = "5")]
    pub started_event_id: i64,
    /// Starting at 1, the number of attempts to complete this task by any worker.
    #[prost(int32, tag = "6")]
    pub attempt: i32,
    /// A hint that there are more tasks already present in this task queue
    /// partition. Can be used to prioritize draining a sticky queue.
    ///
    /// Specifically, the returned number is the number of tasks remaining in
    /// the in-memory buffer for this partition, which is currently capped at
    /// 1000. Because sticky queues only have one partition, this number is
    /// more useful when draining them. Normal queues, typically having more than one
    /// partition, will return a number representing only some portion of the
    /// overall backlog. Subsequent RPCs may not hit the same partition as
    /// this call.
    #[prost(int64, tag = "7")]
    pub backlog_count_hint: i64,
    /// The history for this workflow, which will either be complete or partial. Partial histories
    /// are sent to workers who have signaled that they are using a sticky queue when completing
    /// a workflow task.
    #[prost(message, optional, tag = "8")]
    pub history: ::core::option::Option<super::super::history::v1::History>,
    /// Will be set if there are more history events than were included in this response. Such events
    /// should be fetched via `GetWorkflowExecutionHistory`.
    #[prost(bytes = "vec", tag = "9")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    /// Legacy queries appear in this field. The query must be responded to via
    /// `RespondQueryTaskCompleted`. If the workflow is already closed (queries are permitted on
    /// closed workflows) then the `history` field will be populated with the entire history. It
    /// may also be populated if this task originates on a non-sticky queue.
    #[prost(message, optional, tag = "10")]
    pub query: ::core::option::Option<super::super::query::v1::WorkflowQuery>,
    /// The task queue this task originated from, which will always be the original non-sticky name
    /// for the queue, even if this response came from polling a sticky queue.
    #[prost(message, optional, tag = "11")]
    pub workflow_execution_task_queue: ::core::option::Option<
        super::super::taskqueue::v1::TaskQueue,
    >,
    /// When this task was scheduled by the server
    #[prost(message, optional, tag = "12")]
    pub scheduled_time: ::core::option::Option<::prost_types::Timestamp>,
    /// When the current workflow task started event was generated, meaning the current attempt.
    #[prost(message, optional, tag = "13")]
    pub started_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Queries that should be executed after applying the history in this task. Responses should be
    /// attached to `RespondWorkflowTaskCompletedRequest::query_results`
    #[prost(map = "string, message", tag = "14")]
    pub queries: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::query::v1::WorkflowQuery,
    >,
    /// Protocol messages piggybacking on a WFT as a transport
    #[prost(message, repeated, tag = "15")]
    pub messages: ::prost::alloc::vec::Vec<super::super::protocol::v1::Message>,
    /// Server-advised information the SDK may use to adjust its poller count.
    #[prost(message, optional, tag = "16")]
    pub poller_scaling_decision: ::core::option::Option<
        super::super::taskqueue::v1::PollerScalingDecision,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondWorkflowTaskCompletedRequest {
    /// The task token as received in `PollWorkflowTaskQueueResponse`
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    /// A list of commands generated when driving the workflow code in response to the new task
    #[prost(message, repeated, tag = "2")]
    pub commands: ::prost::alloc::vec::Vec<super::super::command::v1::Command>,
    /// The identity of the worker/client
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    /// May be set by workers to indicate that the worker desires future tasks to be provided with
    /// incremental history on a sticky queue.
    #[prost(message, optional, tag = "4")]
    pub sticky_attributes: ::core::option::Option<
        super::super::taskqueue::v1::StickyExecutionAttributes,
    >,
    /// If set, the worker wishes to immediately receive the next workflow task as a response to
    /// this completion. This can save on polling round-trips.
    #[prost(bool, tag = "5")]
    pub return_new_workflow_task: bool,
    /// Can be used to *force* creation of a new workflow task, even if no commands have resolved or
    /// one would not otherwise have been generated. This is used when the worker knows it is doing
    /// something useful, but cannot complete it within the workflow task timeout. Local activities
    /// which run for longer than the task timeout being the prime example.
    #[prost(bool, tag = "6")]
    pub force_create_new_workflow_task: bool,
    /// Deprecated. Use `deployment_options` instead.
    /// Worker process' unique binary id
    #[deprecated]
    #[prost(string, tag = "7")]
    pub binary_checksum: ::prost::alloc::string::String,
    /// Responses to the `queries` field in the task being responded to
    #[prost(map = "string, message", tag = "8")]
    pub query_results: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::query::v1::WorkflowQueryResult,
    >,
    #[prost(string, tag = "9")]
    pub namespace: ::prost::alloc::string::String,
    /// Version info of the worker who processed this task. This message's `build_id` field should
    /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    /// field to true. See message docstrings for more.
    /// Deprecated. Use `deployment_options` and `versioning_behavior` instead.
    #[deprecated]
    #[prost(message, optional, tag = "10")]
    pub worker_version_stamp: ::core::option::Option<
        super::super::common::v1::WorkerVersionStamp,
    >,
    /// Protocol messages piggybacking on a WFT as a transport
    #[prost(message, repeated, tag = "11")]
    pub messages: ::prost::alloc::vec::Vec<super::super::protocol::v1::Message>,
    /// Data the SDK wishes to record for itself, but server need not interpret, and does not
    /// directly impact workflow state.
    #[prost(message, optional, tag = "12")]
    pub sdk_metadata: ::core::option::Option<
        super::super::sdk::v1::WorkflowTaskCompletedMetadata,
    >,
    /// Local usage data collected for metering
    #[prost(message, optional, tag = "13")]
    pub metering_metadata: ::core::option::Option<
        super::super::common::v1::MeteringMetadata,
    >,
    /// All capabilities the SDK supports.
    #[prost(message, optional, tag = "14")]
    pub capabilities: ::core::option::Option<
        respond_workflow_task_completed_request::Capabilities,
    >,
    /// Deployment info of the worker that completed this task. Must be present if user has set
    /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
    /// Deprecated. Replaced with `deployment_options`.
    #[deprecated]
    #[prost(message, optional, tag = "15")]
    pub deployment: ::core::option::Option<super::super::deployment::v1::Deployment>,
    /// Versioning behavior of this workflow execution as set on the worker that completed this task.
    /// UNSPECIFIED means versioning is not enabled in the worker.
    #[prost(enumeration = "super::super::enums::v1::VersioningBehavior", tag = "16")]
    pub versioning_behavior: i32,
    /// Worker deployment options that user has set in the worker.
    #[prost(message, optional, tag = "17")]
    pub deployment_options: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentOptions,
    >,
}
/// Nested message and enum types in `RespondWorkflowTaskCompletedRequest`.
pub mod respond_workflow_task_completed_request {
    /// SDK capability details.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Capabilities {
        /// True if the SDK can handle speculative workflow task with command events. If true, the
        /// server may choose, at its discretion, to discard a speculative workflow task even if that
        /// speculative task included command events the SDK had not previously processed.
        ///
        /// (-- api-linter: core::0140::prepositions=disabled
        ///      aip.dev/not-precedent: "with" used to describe the workflow task. --)
        #[prost(bool, tag = "1")]
        pub discard_speculative_workflow_task_with_events: bool,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondWorkflowTaskCompletedResponse {
    /// See `RespondWorkflowTaskCompletedResponse::return_new_workflow_task`
    #[prost(message, optional, tag = "1")]
    pub workflow_task: ::core::option::Option<PollWorkflowTaskQueueResponse>,
    /// See `ScheduleActivityTaskCommandAttributes::request_eager_execution`
    #[prost(message, repeated, tag = "2")]
    pub activity_tasks: ::prost::alloc::vec::Vec<PollActivityTaskQueueResponse>,
    /// If non zero, indicates the server has discarded the workflow task that was being responded to.
    /// Will be the event ID of the last workflow task started event in the history before the new workflow task.
    /// Server is only expected to discard a workflow task if it could not have modified the workflow state.
    #[prost(int64, tag = "3")]
    pub reset_history_event_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondWorkflowTaskFailedRequest {
    /// The task token as received in `PollWorkflowTaskQueueResponse`
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    /// Why did the task fail? It's important to note that many of the variants in this enum cannot
    /// apply to worker responses. See the type's doc for more.
    #[prost(enumeration = "super::super::enums::v1::WorkflowTaskFailedCause", tag = "2")]
    pub cause: i32,
    /// Failure details
    #[prost(message, optional, tag = "3")]
    pub failure: ::core::option::Option<super::super::failure::v1::Failure>,
    /// The identity of the worker/client
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
    /// Deprecated. Use `deployment_options` instead.
    /// Worker process' unique binary id
    #[deprecated]
    #[prost(string, tag = "5")]
    pub binary_checksum: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub namespace: ::prost::alloc::string::String,
    /// Protocol messages piggybacking on a WFT as a transport
    #[prost(message, repeated, tag = "7")]
    pub messages: ::prost::alloc::vec::Vec<super::super::protocol::v1::Message>,
    /// Version info of the worker who processed this task. This message's `build_id` field should
    /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    /// field to true. See message docstrings for more.
    /// Deprecated. Use `deployment_options` instead.
    #[deprecated]
    #[prost(message, optional, tag = "8")]
    pub worker_version: ::core::option::Option<
        super::super::common::v1::WorkerVersionStamp,
    >,
    /// Deployment info of the worker that completed this task. Must be present if user has set
    /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
    /// Deprecated. Replaced with `deployment_options`.
    #[deprecated]
    #[prost(message, optional, tag = "9")]
    pub deployment: ::core::option::Option<super::super::deployment::v1::Deployment>,
    /// Worker deployment options that user has set in the worker.
    #[prost(message, optional, tag = "10")]
    pub deployment_options: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentOptions,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondWorkflowTaskFailedResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollActivityTaskQueueRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub task_queue: ::core::option::Option<super::super::taskqueue::v1::TaskQueue>,
    /// The identity of the worker/client
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    /// A unique key for this worker instance, used for tracking worker lifecycle.
    /// This is guaranteed to be unique, whereas identity is not guaranteed to be unique.
    #[prost(string, tag = "7")]
    pub worker_instance_key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub task_queue_metadata: ::core::option::Option<
        super::super::taskqueue::v1::TaskQueueMetadata,
    >,
    /// Information about this worker's build identifier and if it is choosing to use the versioning
    /// feature. See the `WorkerVersionCapabilities` docstring for more.
    /// Deprecated. Replaced by deployment_options.
    #[deprecated]
    #[prost(message, optional, tag = "5")]
    pub worker_version_capabilities: ::core::option::Option<
        super::super::common::v1::WorkerVersionCapabilities,
    >,
    /// Worker deployment options that user has set in the worker.
    #[prost(message, optional, tag = "6")]
    pub deployment_options: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentOptions,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollActivityTaskQueueResponse {
    /// A unique identifier for this task
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    /// The namespace of the activity. If this is a workflow activity then this is the namespace of
    /// the workflow also. If this is a standalone activity then the name of this field is
    /// misleading, but retained for compatibility with workflow activities.
    #[prost(string, tag = "2")]
    pub workflow_namespace: ::prost::alloc::string::String,
    /// Type of the requesting workflow (if this is a workflow activity).
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<super::super::common::v1::WorkflowType>,
    /// Execution info of the requesting workflow (if this is a workflow activity)
    #[prost(message, optional, tag = "4")]
    pub workflow_execution: ::core::option::Option<
        super::super::common::v1::WorkflowExecution,
    >,
    #[prost(message, optional, tag = "5")]
    pub activity_type: ::core::option::Option<super::super::common::v1::ActivityType>,
    /// The autogenerated or user specified identifier of this activity. Can be used to complete the
    /// activity via `RespondActivityTaskCompletedById`. May be re-used as long as the last usage
    /// has resolved, but unique IDs for every activity invocation is a good idea.
    /// Note that only a workflow activity ID may be autogenerated.
    #[prost(string, tag = "6")]
    pub activity_id: ::prost::alloc::string::String,
    /// Headers specified by the scheduling workflow. Commonly used to propagate contextual info
    /// from the workflow to its activities. For example, tracing contexts.
    #[prost(message, optional, tag = "7")]
    pub header: ::core::option::Option<super::super::common::v1::Header>,
    /// Arguments to the activity invocation
    #[prost(message, optional, tag = "8")]
    pub input: ::core::option::Option<super::super::common::v1::Payloads>,
    /// Details of the last heartbeat that was recorded for this activity as of the time this task
    /// was delivered.
    #[prost(message, optional, tag = "9")]
    pub heartbeat_details: ::core::option::Option<super::super::common::v1::Payloads>,
    /// When was this task first scheduled
    #[prost(message, optional, tag = "10")]
    pub scheduled_time: ::core::option::Option<::prost_types::Timestamp>,
    /// When was this task attempt scheduled
    #[prost(message, optional, tag = "11")]
    pub current_attempt_scheduled_time: ::core::option::Option<::prost_types::Timestamp>,
    /// When was this task started (this attempt)
    #[prost(message, optional, tag = "12")]
    pub started_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Starting at 1, the number of attempts to perform this activity
    #[prost(int32, tag = "13")]
    pub attempt: i32,
    /// First scheduled -> final result reported timeout
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: "to" is used to indicate interval. --)
    #[prost(message, optional, tag = "14")]
    pub schedule_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Current attempt start -> final result reported timeout
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: "to" is used to indicate interval. --)
    #[prost(message, optional, tag = "15")]
    pub start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Window within which the activity must report a heartbeat, or be timed out.
    #[prost(message, optional, tag = "16")]
    pub heartbeat_timeout: ::core::option::Option<::prost_types::Duration>,
    /// This is the retry policy the service uses which may be different from the one provided
    /// (or not) during activity scheduling. The service can override the provided one if some
    /// values are not specified or exceed configured system limits.
    #[prost(message, optional, tag = "17")]
    pub retry_policy: ::core::option::Option<super::super::common::v1::RetryPolicy>,
    /// Server-advised information the SDK may use to adjust its poller count.
    #[prost(message, optional, tag = "18")]
    pub poller_scaling_decision: ::core::option::Option<
        super::super::taskqueue::v1::PollerScalingDecision,
    >,
    /// Priority metadata
    #[prost(message, optional, tag = "19")]
    pub priority: ::core::option::Option<super::super::common::v1::Priority>,
    /// The run ID of the activity execution, only set for standalone activities.
    #[prost(string, tag = "20")]
    pub activity_run_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordActivityTaskHeartbeatRequest {
    /// The task token as received in `PollActivityTaskQueueResponse`
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    /// Arbitrary data, of which the most recent call is kept, to store for this activity
    #[prost(message, optional, tag = "2")]
    pub details: ::core::option::Option<super::super::common::v1::Payloads>,
    /// The identity of the worker/client
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub namespace: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecordActivityTaskHeartbeatResponse {
    /// Will be set to true if the activity has been asked to cancel itself. The SDK should then
    /// notify the activity of cancellation if it is still running.
    #[prost(bool, tag = "1")]
    pub cancel_requested: bool,
    /// Will be set to true if the activity is paused.
    #[prost(bool, tag = "2")]
    pub activity_paused: bool,
    /// Will be set to true if the activity was reset.
    /// Applies only to the current run.
    #[prost(bool, tag = "3")]
    pub activity_reset: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordActivityTaskHeartbeatByIdRequest {
    /// Namespace of the workflow which scheduled this activity
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Id of the workflow which scheduled this activity, leave empty to target a standalone activity
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    /// For a workflow activity - the run ID of the workflow which scheduled this activity.
    /// For a standalone activity - the run ID of the activity.
    #[prost(string, tag = "3")]
    pub run_id: ::prost::alloc::string::String,
    /// Id of the activity we're heartbeating
    #[prost(string, tag = "4")]
    pub activity_id: ::prost::alloc::string::String,
    /// Arbitrary data, of which the most recent call is kept, to store for this activity
    #[prost(message, optional, tag = "5")]
    pub details: ::core::option::Option<super::super::common::v1::Payloads>,
    /// The identity of the worker/client
    #[prost(string, tag = "6")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecordActivityTaskHeartbeatByIdResponse {
    /// Will be set to true if the activity has been asked to cancel itself. The SDK should then
    /// notify the activity of cancellation if it is still running.
    #[prost(bool, tag = "1")]
    pub cancel_requested: bool,
    /// Will be set to true if the activity is paused.
    #[prost(bool, tag = "2")]
    pub activity_paused: bool,
    /// Will be set to true if the activity was reset.
    /// Applies only to the current run.
    #[prost(bool, tag = "3")]
    pub activity_reset: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCompletedRequest {
    /// The task token as received in `PollActivityTaskQueueResponse`
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    /// The result of successfully executing the activity
    #[prost(message, optional, tag = "2")]
    pub result: ::core::option::Option<super::super::common::v1::Payloads>,
    /// The identity of the worker/client
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub namespace: ::prost::alloc::string::String,
    /// Version info of the worker who processed this task. This message's `build_id` field should
    /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    /// field to true. See message docstrings for more.
    /// Deprecated. Use `deployment_options` instead.
    #[deprecated]
    #[prost(message, optional, tag = "5")]
    pub worker_version: ::core::option::Option<
        super::super::common::v1::WorkerVersionStamp,
    >,
    /// Deployment info of the worker that completed this task. Must be present if user has set
    /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
    /// Deprecated. Replaced with `deployment_options`.
    #[deprecated]
    #[prost(message, optional, tag = "6")]
    pub deployment: ::core::option::Option<super::super::deployment::v1::Deployment>,
    /// Worker deployment options that user has set in the worker.
    #[prost(message, optional, tag = "7")]
    pub deployment_options: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentOptions,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCompletedResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCompletedByIdRequest {
    /// Namespace of the workflow which scheduled this activity
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Id of the workflow which scheduled this activity, leave empty to target a standalone activity
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    /// For a workflow activity - the run ID of the workflow which scheduled this activity.
    /// For a standalone activity - the run ID of the activity.
    #[prost(string, tag = "3")]
    pub run_id: ::prost::alloc::string::String,
    /// Id of the activity to complete
    #[prost(string, tag = "4")]
    pub activity_id: ::prost::alloc::string::String,
    /// The serialized result of activity execution
    #[prost(message, optional, tag = "5")]
    pub result: ::core::option::Option<super::super::common::v1::Payloads>,
    /// The identity of the worker/client
    #[prost(string, tag = "6")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCompletedByIdResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskFailedRequest {
    /// The task token as received in `PollActivityTaskQueueResponse`
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    /// Detailed failure information
    #[prost(message, optional, tag = "2")]
    pub failure: ::core::option::Option<super::super::failure::v1::Failure>,
    /// The identity of the worker/client
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub namespace: ::prost::alloc::string::String,
    /// Additional details to be stored as last activity heartbeat
    #[prost(message, optional, tag = "5")]
    pub last_heartbeat_details: ::core::option::Option<
        super::super::common::v1::Payloads,
    >,
    /// Version info of the worker who processed this task. This message's `build_id` field should
    /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    /// field to true. See message docstrings for more.
    /// Deprecated. Use `deployment_options` instead.
    #[deprecated]
    #[prost(message, optional, tag = "6")]
    pub worker_version: ::core::option::Option<
        super::super::common::v1::WorkerVersionStamp,
    >,
    /// Deployment info of the worker that completed this task. Must be present if user has set
    /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
    /// Deprecated. Replaced with `deployment_options`.
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub deployment: ::core::option::Option<super::super::deployment::v1::Deployment>,
    /// Worker deployment options that user has set in the worker.
    #[prost(message, optional, tag = "8")]
    pub deployment_options: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentOptions,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskFailedResponse {
    /// Server validation failures could include
    /// last_heartbeat_details payload is too large, request failure is too large
    #[prost(message, repeated, tag = "1")]
    pub failures: ::prost::alloc::vec::Vec<super::super::failure::v1::Failure>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskFailedByIdRequest {
    /// Namespace of the workflow which scheduled this activity
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Id of the workflow which scheduled this activity, leave empty to target a standalone activity
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    /// For a workflow activity - the run ID of the workflow which scheduled this activity.
    /// For a standalone activity - the run ID of the activity.
    #[prost(string, tag = "3")]
    pub run_id: ::prost::alloc::string::String,
    /// Id of the activity to fail
    #[prost(string, tag = "4")]
    pub activity_id: ::prost::alloc::string::String,
    /// Detailed failure information
    #[prost(message, optional, tag = "5")]
    pub failure: ::core::option::Option<super::super::failure::v1::Failure>,
    /// The identity of the worker/client
    #[prost(string, tag = "6")]
    pub identity: ::prost::alloc::string::String,
    /// Additional details to be stored as last activity heartbeat
    #[prost(message, optional, tag = "7")]
    pub last_heartbeat_details: ::core::option::Option<
        super::super::common::v1::Payloads,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskFailedByIdResponse {
    /// Server validation failures could include
    /// last_heartbeat_details payload is too large, request failure is too large
    #[prost(message, repeated, tag = "1")]
    pub failures: ::prost::alloc::vec::Vec<super::super::failure::v1::Failure>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCanceledRequest {
    /// The task token as received in `PollActivityTaskQueueResponse`
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    /// Serialized additional information to attach to the cancellation
    #[prost(message, optional, tag = "2")]
    pub details: ::core::option::Option<super::super::common::v1::Payloads>,
    /// The identity of the worker/client
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub namespace: ::prost::alloc::string::String,
    /// Version info of the worker who processed this task. This message's `build_id` field should
    /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    /// field to true. See message docstrings for more.
    /// Deprecated. Use `deployment_options` instead.
    #[deprecated]
    #[prost(message, optional, tag = "5")]
    pub worker_version: ::core::option::Option<
        super::super::common::v1::WorkerVersionStamp,
    >,
    /// Deployment info of the worker that completed this task. Must be present if user has set
    /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
    /// Deprecated. Replaced with `deployment_options`.
    #[deprecated]
    #[prost(message, optional, tag = "6")]
    pub deployment: ::core::option::Option<super::super::deployment::v1::Deployment>,
    /// Worker deployment options that user has set in the worker.
    #[prost(message, optional, tag = "7")]
    pub deployment_options: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentOptions,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCanceledResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCanceledByIdRequest {
    /// Namespace of the workflow which scheduled this activity
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Id of the workflow which scheduled this activity, leave empty to target a standalone activity
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    /// For a workflow activity - the run ID of the workflow which scheduled this activity.
    /// For a standalone activity - the run ID of the activity.
    #[prost(string, tag = "3")]
    pub run_id: ::prost::alloc::string::String,
    /// Id of the activity to confirm is cancelled
    #[prost(string, tag = "4")]
    pub activity_id: ::prost::alloc::string::String,
    /// Serialized additional information to attach to the cancellation
    #[prost(message, optional, tag = "5")]
    pub details: ::core::option::Option<super::super::common::v1::Payloads>,
    /// The identity of the worker/client
    #[prost(string, tag = "6")]
    pub identity: ::prost::alloc::string::String,
    /// Worker deployment options that user has set in the worker.
    #[prost(message, optional, tag = "7")]
    pub deployment_options: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentOptions,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCanceledByIdResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestCancelWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<
        super::super::common::v1::WorkflowExecution,
    >,
    /// The identity of the worker/client
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    /// Used to de-dupe cancellation requests
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    /// If set, this call will error if the most recent (if no run id is set on
    /// `workflow_execution`), or specified (if it is) workflow execution is not part of the same
    /// execution chain as this id.
    #[prost(string, tag = "5")]
    pub first_execution_run_id: ::prost::alloc::string::String,
    /// Reason for requesting the cancellation
    #[prost(string, tag = "6")]
    pub reason: ::prost::alloc::string::String,
    /// Links to be associated with the WorkflowExecutionCanceled event.
    #[prost(message, repeated, tag = "7")]
    pub links: ::prost::alloc::vec::Vec<super::super::common::v1::Link>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestCancelWorkflowExecutionResponse {}
/// Keep the parameters in sync with:
///    - temporal.api.batch.v1.BatchOperationSignal.
///    - temporal.api.workflow.v1.PostResetOperation.SignalWorkflow.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<
        super::super::common::v1::WorkflowExecution,
    >,
    /// The workflow author-defined name of the signal to send to the workflow
    #[prost(string, tag = "3")]
    pub signal_name: ::prost::alloc::string::String,
    /// Serialized value(s) to provide with the signal
    #[prost(message, optional, tag = "4")]
    pub input: ::core::option::Option<super::super::common::v1::Payloads>,
    /// The identity of the worker/client
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
    /// Used to de-dupe sent signals
    #[prost(string, tag = "6")]
    pub request_id: ::prost::alloc::string::String,
    /// Deprecated.
    #[deprecated]
    #[prost(string, tag = "7")]
    pub control: ::prost::alloc::string::String,
    /// Headers that are passed with the signal to the processing workflow.
    /// These can include things like auth or tracing tokens.
    #[prost(message, optional, tag = "8")]
    pub header: ::core::option::Option<super::super::common::v1::Header>,
    /// Links to be associated with the WorkflowExecutionSignaled event.
    #[prost(message, repeated, tag = "10")]
    pub links: ::prost::alloc::vec::Vec<super::super::common::v1::Link>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SignalWorkflowExecutionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalWithStartWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<super::super::common::v1::WorkflowType>,
    /// The task queue to start this workflow on, if it will be started
    #[prost(message, optional, tag = "4")]
    pub task_queue: ::core::option::Option<super::super::taskqueue::v1::TaskQueue>,
    /// Serialized arguments to the workflow. These are passed as arguments to the workflow function.
    #[prost(message, optional, tag = "5")]
    pub input: ::core::option::Option<super::super::common::v1::Payloads>,
    /// Total workflow execution timeout including retries and continue as new
    #[prost(message, optional, tag = "6")]
    pub workflow_execution_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Timeout of a single workflow run
    #[prost(message, optional, tag = "7")]
    pub workflow_run_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Timeout of a single workflow task
    #[prost(message, optional, tag = "8")]
    pub workflow_task_timeout: ::core::option::Option<::prost_types::Duration>,
    /// The identity of the worker/client
    #[prost(string, tag = "9")]
    pub identity: ::prost::alloc::string::String,
    /// Used to de-dupe signal w/ start requests
    #[prost(string, tag = "10")]
    pub request_id: ::prost::alloc::string::String,
    /// Defines whether to allow re-using the workflow id from a previously *closed* workflow.
    /// The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    ///
    /// See `workflow_id_reuse_policy` for handling a workflow id duplication with a *running* workflow.
    #[prost(enumeration = "super::super::enums::v1::WorkflowIdReusePolicy", tag = "11")]
    pub workflow_id_reuse_policy: i32,
    /// Defines how to resolve a workflow id conflict with a *running* workflow.
    /// The default policy is WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING.
    /// Note that WORKFLOW_ID_CONFLICT_POLICY_FAIL is an invalid option.
    ///
    /// See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
    #[prost(
        enumeration = "super::super::enums::v1::WorkflowIdConflictPolicy",
        tag = "22"
    )]
    pub workflow_id_conflict_policy: i32,
    /// The workflow author-defined name of the signal to send to the workflow
    #[prost(string, tag = "12")]
    pub signal_name: ::prost::alloc::string::String,
    /// Serialized value(s) to provide with the signal
    #[prost(message, optional, tag = "13")]
    pub signal_input: ::core::option::Option<super::super::common::v1::Payloads>,
    /// Deprecated.
    #[deprecated]
    #[prost(string, tag = "14")]
    pub control: ::prost::alloc::string::String,
    /// Retry policy for the workflow
    #[prost(message, optional, tag = "15")]
    pub retry_policy: ::core::option::Option<super::super::common::v1::RetryPolicy>,
    /// See <https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/>
    #[prost(string, tag = "16")]
    pub cron_schedule: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "17")]
    pub memo: ::core::option::Option<super::super::common::v1::Memo>,
    #[prost(message, optional, tag = "18")]
    pub search_attributes: ::core::option::Option<
        super::super::common::v1::SearchAttributes,
    >,
    #[prost(message, optional, tag = "19")]
    pub header: ::core::option::Option<super::super::common::v1::Header>,
    /// Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
    /// Note that the signal will be delivered with the first workflow task. If the workflow gets
    /// another SignalWithStartWorkflow before the delay a workflow task will be dispatched immediately
    /// and the rest of the delay period will be ignored, even if that request also had a delay.
    /// Signal via SignalWorkflowExecution will not unblock the workflow.
    #[prost(message, optional, tag = "20")]
    pub workflow_start_delay: ::core::option::Option<::prost_types::Duration>,
    /// Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo
    /// for use by user interfaces to display the fixed as-of-start summary and details of the
    /// workflow.
    #[prost(message, optional, tag = "23")]
    pub user_metadata: ::core::option::Option<super::super::sdk::v1::UserMetadata>,
    /// Links to be associated with the WorkflowExecutionStarted and WorkflowExecutionSignaled events.
    #[prost(message, repeated, tag = "24")]
    pub links: ::prost::alloc::vec::Vec<super::super::common::v1::Link>,
    /// If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
    /// To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
    #[prost(message, optional, tag = "25")]
    pub versioning_override: ::core::option::Option<
        super::super::workflow::v1::VersioningOverride,
    >,
    /// Priority metadata
    #[prost(message, optional, tag = "26")]
    pub priority: ::core::option::Option<super::super::common::v1::Priority>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalWithStartWorkflowExecutionResponse {
    /// The run id of the workflow that was started - or just signaled, if it was already running.
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
    /// If true, a new workflow was started.
    #[prost(bool, tag = "2")]
    pub started: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The workflow to reset. If this contains a run ID then the workflow will be reset back to the
    /// provided event ID in that run. Otherwise it will be reset to the provided event ID in the
    /// current run. In all cases the current run will be terminated and a new run started.
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<
        super::super::common::v1::WorkflowExecution,
    >,
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
    /// The id of a `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
    /// `WORKFLOW_TASK_STARTED` event to reset to.
    #[prost(int64, tag = "4")]
    pub workflow_task_finish_event_id: i64,
    /// Used to de-dupe reset requests
    #[prost(string, tag = "5")]
    pub request_id: ::prost::alloc::string::String,
    /// Deprecated. Use `options`.
    /// Default: RESET_REAPPLY_TYPE_SIGNAL
    #[deprecated]
    #[prost(enumeration = "super::super::enums::v1::ResetReapplyType", tag = "6")]
    pub reset_reapply_type: i32,
    /// Event types not to be reapplied
    #[prost(
        enumeration = "super::super::enums::v1::ResetReapplyExcludeType",
        repeated,
        tag = "7"
    )]
    pub reset_reapply_exclude_types: ::prost::alloc::vec::Vec<i32>,
    /// Operations to perform after the workflow has been reset. These operations will be applied
    /// to the *new* run of the workflow execution in the order they are provided.
    /// All operations are applied to the workflow before the first new workflow task is generated
    #[prost(message, repeated, tag = "8")]
    pub post_reset_operations: ::prost::alloc::vec::Vec<
        super::super::workflow::v1::PostResetOperation,
    >,
    /// The identity of the worker/client
    #[prost(string, tag = "9")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetWorkflowExecutionResponse {
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminateWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<
        super::super::common::v1::WorkflowExecution,
    >,
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
    /// Serialized additional information to attach to the termination event
    #[prost(message, optional, tag = "4")]
    pub details: ::core::option::Option<super::super::common::v1::Payloads>,
    /// The identity of the worker/client
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
    /// If set, this call will error if the most recent (if no run id is set on
    /// `workflow_execution`), or specified (if it is) workflow execution is not part of the same
    /// execution chain as this id.
    #[prost(string, tag = "6")]
    pub first_execution_run_id: ::prost::alloc::string::String,
    /// Links to be associated with the WorkflowExecutionTerminated event.
    #[prost(message, repeated, tag = "7")]
    pub links: ::prost::alloc::vec::Vec<super::super::common::v1::Link>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TerminateWorkflowExecutionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Workflow Execution to delete. If run_id is not specified, the latest one is used.
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<
        super::super::common::v1::WorkflowExecution,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteWorkflowExecutionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOpenWorkflowExecutionsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub maximum_page_size: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub start_time_filter: ::core::option::Option<
        super::super::filter::v1::StartTimeFilter,
    >,
    #[prost(oneof = "list_open_workflow_executions_request::Filters", tags = "5, 6")]
    pub filters: ::core::option::Option<list_open_workflow_executions_request::Filters>,
}
/// Nested message and enum types in `ListOpenWorkflowExecutionsRequest`.
pub mod list_open_workflow_executions_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filters {
        #[prost(message, tag = "5")]
        ExecutionFilter(super::super::super::filter::v1::WorkflowExecutionFilter),
        #[prost(message, tag = "6")]
        TypeFilter(super::super::super::filter::v1::WorkflowTypeFilter),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOpenWorkflowExecutionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub executions: ::prost::alloc::vec::Vec<
        super::super::workflow::v1::WorkflowExecutionInfo,
    >,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClosedWorkflowExecutionsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub maximum_page_size: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub start_time_filter: ::core::option::Option<
        super::super::filter::v1::StartTimeFilter,
    >,
    #[prost(
        oneof = "list_closed_workflow_executions_request::Filters",
        tags = "5, 6, 7"
    )]
    pub filters: ::core::option::Option<
        list_closed_workflow_executions_request::Filters,
    >,
}
/// Nested message and enum types in `ListClosedWorkflowExecutionsRequest`.
pub mod list_closed_workflow_executions_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filters {
        #[prost(message, tag = "5")]
        ExecutionFilter(super::super::super::filter::v1::WorkflowExecutionFilter),
        #[prost(message, tag = "6")]
        TypeFilter(super::super::super::filter::v1::WorkflowTypeFilter),
        #[prost(message, tag = "7")]
        StatusFilter(super::super::super::filter::v1::StatusFilter),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClosedWorkflowExecutionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub executions: ::prost::alloc::vec::Vec<
        super::super::workflow::v1::WorkflowExecutionInfo,
    >,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkflowExecutionsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkflowExecutionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub executions: ::prost::alloc::vec::Vec<
        super::super::workflow::v1::WorkflowExecutionInfo,
    >,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListArchivedWorkflowExecutionsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListArchivedWorkflowExecutionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub executions: ::prost::alloc::vec::Vec<
        super::super::workflow::v1::WorkflowExecutionInfo,
    >,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
/// Deprecated: Use with `ListWorkflowExecutions`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScanWorkflowExecutionsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
}
/// Deprecated: Use with `ListWorkflowExecutions`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScanWorkflowExecutionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub executions: ::prost::alloc::vec::Vec<
        super::super::workflow::v1::WorkflowExecutionInfo,
    >,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountWorkflowExecutionsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountWorkflowExecutionsResponse {
    /// If `query` is not grouping by any field, the count is an approximate number
    /// of workflows that matches the query.
    /// If `query` is grouping by a field, the count is simply the sum of the counts
    /// of the groups returned in the response. This number can be smaller than the
    /// total number of workflows matching the query.
    #[prost(int64, tag = "1")]
    pub count: i64,
    /// `groups` contains the groups if the request is grouping by a field.
    /// The list might not be complete, and the counts of each group is approximate.
    #[prost(message, repeated, tag = "2")]
    pub groups: ::prost::alloc::vec::Vec<
        count_workflow_executions_response::AggregationGroup,
    >,
}
/// Nested message and enum types in `CountWorkflowExecutionsResponse`.
pub mod count_workflow_executions_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AggregationGroup {
        #[prost(message, repeated, tag = "1")]
        pub group_values: ::prost::alloc::vec::Vec<
            super::super::super::common::v1::Payload,
        >,
        #[prost(int64, tag = "2")]
        pub count: i64,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSearchAttributesRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSearchAttributesResponse {
    #[prost(
        map = "string, enumeration(super::super::enums::v1::IndexedValueType)",
        tag = "1"
    )]
    pub keys: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondQueryTaskCompletedRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "super::super::enums::v1::QueryResultType", tag = "2")]
    pub completed_type: i32,
    /// The result of the query.
    /// Mutually exclusive with `error_message` and `failure`. Set when the query succeeds.
    #[prost(message, optional, tag = "3")]
    pub query_result: ::core::option::Option<super::super::common::v1::Payloads>,
    /// A plain error message that must be set if completed_type is QUERY_RESULT_TYPE_FAILED.
    /// SDKs should also fill in the more complete `failure` field to provide the full context and
    /// support encryption of failure information.
    /// `error_message` will be duplicated if the `failure` field is present to support callers
    /// that pre-date the addition of that field, regardless of whether or not a custom failure
    /// converter is used.
    /// Mutually exclusive with `query_result`. Set when the query fails.
    #[prost(string, tag = "4")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub namespace: ::prost::alloc::string::String,
    /// The full reason for this query failure. This field is newer than `error_message` and can be
    /// encoded by the SDK's failure converter to support E2E encryption of messages and stack
    /// traces.
    /// Mutually exclusive with `query_result`. Set when the query fails.
    #[prost(message, optional, tag = "7")]
    pub failure: ::core::option::Option<super::super::failure::v1::Failure>,
    /// Why did the task fail? It's important to note that many of the variants in this enum cannot
    /// apply to worker responses. See the type's doc for more.
    #[prost(enumeration = "super::super::enums::v1::WorkflowTaskFailedCause", tag = "8")]
    pub cause: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondQueryTaskCompletedResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetStickyTaskQueueRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub execution: ::core::option::Option<super::super::common::v1::WorkflowExecution>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResetStickyTaskQueueResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownWorkerRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// sticky_task_queue may not always be populated. We want to ensure all workers
    /// send a shutdown request to update worker state for heartbeating, as well
    /// as cancel pending poll calls early, instead of waiting for timeouts.
    #[prost(string, tag = "2")]
    pub sticky_task_queue: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub worker_heartbeat: ::core::option::Option<
        super::super::worker::v1::WorkerHeartbeat,
    >,
    /// Technically this is also sent in the WorkerHeartbeat, but
    /// since worker heartbeating can be turned off, this needs
    /// to be a separate, top-level field.
    #[prost(string, tag = "6")]
    pub worker_instance_key: ::prost::alloc::string::String,
    /// Task queue name the worker is polling on. This allows server to cancel
    /// all outstanding poll RPC calls from SDK. This avoids a race condition that
    /// can lead to tasks being lost.
    #[prost(string, tag = "7")]
    pub task_queue: ::prost::alloc::string::String,
    /// Task queue types that help server cancel outstanding poll RPC
    /// calls from SDK. This avoids a race condition that can lead to tasks being lost.
    #[prost(enumeration = "super::super::enums::v1::TaskQueueType", repeated, tag = "8")]
    pub task_queue_types: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShutdownWorkerResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryWorkflowRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub execution: ::core::option::Option<super::super::common::v1::WorkflowExecution>,
    #[prost(message, optional, tag = "3")]
    pub query: ::core::option::Option<super::super::query::v1::WorkflowQuery>,
    /// QueryRejectCondition can used to reject the query if workflow state does not satisfy condition.
    /// Default: QUERY_REJECT_CONDITION_NONE.
    #[prost(enumeration = "super::super::enums::v1::QueryRejectCondition", tag = "4")]
    pub query_reject_condition: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryWorkflowResponse {
    #[prost(message, optional, tag = "1")]
    pub query_result: ::core::option::Option<super::super::common::v1::Payloads>,
    #[prost(message, optional, tag = "2")]
    pub query_rejected: ::core::option::Option<super::super::query::v1::QueryRejected>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub execution: ::core::option::Option<super::super::common::v1::WorkflowExecution>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeWorkflowExecutionResponse {
    #[prost(message, optional, tag = "1")]
    pub execution_config: ::core::option::Option<
        super::super::workflow::v1::WorkflowExecutionConfig,
    >,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution_info: ::core::option::Option<
        super::super::workflow::v1::WorkflowExecutionInfo,
    >,
    #[prost(message, repeated, tag = "3")]
    pub pending_activities: ::prost::alloc::vec::Vec<
        super::super::workflow::v1::PendingActivityInfo,
    >,
    #[prost(message, repeated, tag = "4")]
    pub pending_children: ::prost::alloc::vec::Vec<
        super::super::workflow::v1::PendingChildExecutionInfo,
    >,
    #[prost(message, optional, tag = "5")]
    pub pending_workflow_task: ::core::option::Option<
        super::super::workflow::v1::PendingWorkflowTaskInfo,
    >,
    #[prost(message, repeated, tag = "6")]
    pub callbacks: ::prost::alloc::vec::Vec<super::super::workflow::v1::CallbackInfo>,
    #[prost(message, repeated, tag = "7")]
    pub pending_nexus_operations: ::prost::alloc::vec::Vec<
        super::super::workflow::v1::PendingNexusOperationInfo,
    >,
    #[prost(message, optional, tag = "8")]
    pub workflow_extended_info: ::core::option::Option<
        super::super::workflow::v1::WorkflowExecutionExtendedInfo,
    >,
}
/// (-- api-linter: core::0203::optional=disabled
///      aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeTaskQueueRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Sticky queues are not supported in deprecated ENHANCED mode.
    #[prost(message, optional, tag = "2")]
    pub task_queue: ::core::option::Option<super::super::taskqueue::v1::TaskQueue>,
    /// If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.
    /// Only supported in default mode (use `task_queue_types` in ENHANCED mode instead).
    #[prost(enumeration = "super::super::enums::v1::TaskQueueType", tag = "3")]
    pub task_queue_type: i32,
    /// Report stats for the requested task queue type(s).
    #[prost(bool, tag = "8")]
    pub report_stats: bool,
    /// Report Task Queue Config
    #[prost(bool, tag = "11")]
    pub report_config: bool,
    /// Deprecated, use `report_stats` instead.
    /// If true, the task queue status will be included in the response.
    #[deprecated]
    #[prost(bool, tag = "4")]
    pub include_task_queue_status: bool,
    /// Deprecated. ENHANCED mode is also being deprecated.
    /// Select the API mode to use for this request: DEFAULT mode (if unset) or ENHANCED mode.
    /// Consult the documentation for each field to understand which mode it is supported in.
    #[deprecated]
    #[prost(enumeration = "super::super::enums::v1::DescribeTaskQueueMode", tag = "5")]
    pub api_mode: i32,
    /// Deprecated (as part of the ENHANCED mode deprecation).
    /// Optional. If not provided, the result for the default Build ID will be returned. The default Build ID is the one
    /// mentioned in the first unconditional Assignment Rule. If there is no default Build ID, the result for the
    /// unversioned queue will be returned.
    /// (-- api-linter: core::0140::prepositions --)
    #[deprecated]
    #[prost(message, optional, tag = "6")]
    pub versions: ::core::option::Option<
        super::super::taskqueue::v1::TaskQueueVersionSelection,
    >,
    /// Deprecated (as part of the ENHANCED mode deprecation).
    /// Task queue types to report info about. If not specified, all types are considered.
    #[deprecated]
    #[prost(
        enumeration = "super::super::enums::v1::TaskQueueType",
        repeated,
        packed = "false",
        tag = "7"
    )]
    pub task_queue_types: ::prost::alloc::vec::Vec<i32>,
    /// Deprecated (as part of the ENHANCED mode deprecation).
    /// Report list of pollers for requested task queue types and versions.
    #[deprecated]
    #[prost(bool, tag = "9")]
    pub report_pollers: bool,
    /// Deprecated (as part of the ENHANCED mode deprecation).
    /// Report task reachability for the requested versions and all task types (task reachability is not reported
    /// per task type).
    #[deprecated]
    #[prost(bool, tag = "10")]
    pub report_task_reachability: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeTaskQueueResponse {
    #[prost(message, repeated, tag = "1")]
    pub pollers: ::prost::alloc::vec::Vec<super::super::taskqueue::v1::PollerInfo>,
    /// Statistics for the task queue.
    /// Only set if `report_stats` is set on the request.
    #[prost(message, optional, tag = "5")]
    pub stats: ::core::option::Option<super::super::taskqueue::v1::TaskQueueStats>,
    /// Task queue stats breakdown by priority key. Only contains actively used priority keys.
    /// Only set if `report_stats` is set on the request.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: "by" is used to clarify the keys and values. --)
    #[prost(map = "int32, message", tag = "8")]
    pub stats_by_priority_key: ::std::collections::HashMap<
        i32,
        super::super::taskqueue::v1::TaskQueueStats,
    >,
    /// Specifies which Worker Deployment Version(s) Server routes this Task Queue's tasks to.
    /// When not present, it means the tasks are routed to Unversioned workers (workers with
    /// UNVERSIONED or unspecified WorkerVersioningMode.)
    /// Task Queue Versioning info is updated indirectly by calling SetWorkerDeploymentCurrentVersion
    /// and SetWorkerDeploymentRampingVersion on Worker Deployments.
    /// Note: This information is not relevant to Pinned workflow executions and their activities as
    /// they are always routed to their Pinned Deployment Version. However, new workflow executions
    /// are typically not Pinned until they complete their first task (unless they are started with
    /// a Pinned VersioningOverride or are Child Workflows of a Pinned parent).
    #[prost(message, optional, tag = "4")]
    pub versioning_info: ::core::option::Option<
        super::super::taskqueue::v1::TaskQueueVersioningInfo,
    >,
    /// Only populated if report_task_queue_config is set to true.
    #[prost(message, optional, tag = "6")]
    pub config: ::core::option::Option<super::super::taskqueue::v1::TaskQueueConfig>,
    #[prost(message, optional, tag = "7")]
    pub effective_rate_limit: ::core::option::Option<
        describe_task_queue_response::EffectiveRateLimit,
    >,
    /// Deprecated.
    /// Status of the task queue. Only populated when `include_task_queue_status` is set to true in the request.
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub task_queue_status: ::core::option::Option<
        super::super::taskqueue::v1::TaskQueueStatus,
    >,
    /// Deprecated.
    /// Only returned in ENHANCED mode.
    /// This map contains Task Queue information for each Build ID. Empty string as key value means unversioned.
    #[prost(map = "string, message", tag = "3")]
    pub versions_info: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::taskqueue::v1::TaskQueueVersionInfo,
    >,
}
/// Nested message and enum types in `DescribeTaskQueueResponse`.
pub mod describe_task_queue_response {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct EffectiveRateLimit {
        /// The effective rate limit for the task queue.
        #[prost(float, tag = "1")]
        pub requests_per_second: f32,
        /// Source of the RateLimit Configuration,which can be one of the following values:
        /// - SOURCE_API: The rate limit that is set via the TaskQueueConfig api.
        /// - SOURCE_WORKER: The rate limit is the value set using the workerOptions in TaskQueueActivitiesPerSecond.
        /// - SOURCE_SYSTEM: The rate limit is the default value set by the system
        #[prost(
            enumeration = "super::super::super::enums::v1::RateLimitSource",
            tag = "2"
        )]
        pub rate_limit_source: i32,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetClusterInfoRequest {}
/// GetClusterInfoResponse contains information about Temporal cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClusterInfoResponse {
    /// Key is client name i.e "temporal-go", "temporal-java", or "temporal-cli".
    /// Value is ranges of supported versions of this client i.e ">1.1.1 <=1.4.0 || ^5.0.0".
    #[prost(map = "string, string", tag = "1")]
    pub supported_clients: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "2")]
    pub server_version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub version_info: ::core::option::Option<super::super::version::v1::VersionInfo>,
    #[prost(string, tag = "5")]
    pub cluster_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub history_shard_count: i32,
    #[prost(string, tag = "7")]
    pub persistence_store: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub visibility_store: ::prost::alloc::string::String,
    #[prost(int64, tag = "9")]
    pub initial_failover_version: i64,
    #[prost(int64, tag = "10")]
    pub failover_version_increment: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSystemInfoRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemInfoResponse {
    /// Version of the server.
    #[prost(string, tag = "1")]
    pub server_version: ::prost::alloc::string::String,
    /// All capabilities the system supports.
    #[prost(message, optional, tag = "2")]
    pub capabilities: ::core::option::Option<get_system_info_response::Capabilities>,
}
/// Nested message and enum types in `GetSystemInfoResponse`.
pub mod get_system_info_response {
    /// System capability details.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Capabilities {
        /// True if signal and query headers are supported.
        #[prost(bool, tag = "1")]
        pub signal_and_query_header: bool,
        /// True if internal errors are differentiated from other types of errors for purposes of
        /// retrying non-internal errors.
        ///
        /// When unset/false, clients retry all failures. When true, clients should only retry
        /// non-internal errors.
        #[prost(bool, tag = "2")]
        pub internal_error_differentiation: bool,
        /// True if RespondActivityTaskFailed API supports including heartbeat details
        #[prost(bool, tag = "3")]
        pub activity_failure_include_heartbeat: bool,
        /// Supports scheduled workflow features.
        #[prost(bool, tag = "4")]
        pub supports_schedules: bool,
        /// True if server uses protos that include temporal.api.failure.v1.Failure.encoded_attributes
        #[prost(bool, tag = "5")]
        pub encoded_failure_attributes: bool,
        /// True if server supports dispatching Workflow and Activity tasks based on a worker's build_id
        /// (see:
        /// <https://github.com/temporalio/proposals/blob/a123af3b559f43db16ea6dd31870bfb754c4dc5e/versioning/worker-versions.md>)
        #[prost(bool, tag = "6")]
        pub build_id_based_versioning: bool,
        /// True if server supports upserting workflow memo
        #[prost(bool, tag = "7")]
        pub upsert_memo: bool,
        /// True if server supports eager workflow task dispatching for the StartWorkflowExecution API
        #[prost(bool, tag = "8")]
        pub eager_workflow_start: bool,
        /// True if the server knows about the sdk metadata field on WFT completions and will record
        /// it in history
        #[prost(bool, tag = "9")]
        pub sdk_metadata: bool,
        /// True if the server supports count group by execution status
        /// (-- api-linter: core::0140::prepositions=disabled --)
        #[prost(bool, tag = "10")]
        pub count_group_by_execution_status: bool,
        /// True if the server supports Nexus operations.
        /// This flag is dependent both on server version and for Nexus to be enabled via server configuration.
        #[prost(bool, tag = "11")]
        pub nexus: bool,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTaskQueuePartitionsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub task_queue: ::core::option::Option<super::super::taskqueue::v1::TaskQueue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTaskQueuePartitionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub activity_task_queue_partitions: ::prost::alloc::vec::Vec<
        super::super::taskqueue::v1::TaskQueuePartitionMetadata,
    >,
    #[prost(message, repeated, tag = "2")]
    pub workflow_task_queue_partitions: ::prost::alloc::vec::Vec<
        super::super::taskqueue::v1::TaskQueuePartitionMetadata,
    >,
}
/// (-- api-linter: core::0203::optional=disabled
///      aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateScheduleRequest {
    /// The namespace the schedule should be created in.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The id of the new schedule.
    #[prost(string, tag = "2")]
    pub schedule_id: ::prost::alloc::string::String,
    /// The schedule spec, policies, action, and initial state.
    #[prost(message, optional, tag = "3")]
    pub schedule: ::core::option::Option<super::super::schedule::v1::Schedule>,
    /// Optional initial patch (e.g. to run the action once immediately).
    #[prost(message, optional, tag = "4")]
    pub initial_patch: ::core::option::Option<super::super::schedule::v1::SchedulePatch>,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
    /// A unique identifier for this create request for idempotence. Typically UUIDv4.
    #[prost(string, tag = "6")]
    pub request_id: ::prost::alloc::string::String,
    /// Memo and search attributes to attach to the schedule itself.
    #[prost(message, optional, tag = "7")]
    pub memo: ::core::option::Option<super::super::common::v1::Memo>,
    #[prost(message, optional, tag = "8")]
    pub search_attributes: ::core::option::Option<
        super::super::common::v1::SearchAttributes,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateScheduleResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub conflict_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeScheduleRequest {
    /// The namespace of the schedule to describe.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The id of the schedule to describe.
    #[prost(string, tag = "2")]
    pub schedule_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeScheduleResponse {
    /// The complete current schedule details. This may not match the schedule as
    /// created because:
    /// - some types of schedule specs may get compiled into others (e.g.
    ///    CronString into StructuredCalendarSpec)
    /// - some unspecified fields may be replaced by defaults
    /// - some fields in the state are modified automatically
    /// - the schedule may have been modified by UpdateSchedule or PatchSchedule
    #[prost(message, optional, tag = "1")]
    pub schedule: ::core::option::Option<super::super::schedule::v1::Schedule>,
    /// Extra schedule state info.
    #[prost(message, optional, tag = "2")]
    pub info: ::core::option::Option<super::super::schedule::v1::ScheduleInfo>,
    /// The memo and search attributes that the schedule was created with.
    #[prost(message, optional, tag = "3")]
    pub memo: ::core::option::Option<super::super::common::v1::Memo>,
    #[prost(message, optional, tag = "4")]
    pub search_attributes: ::core::option::Option<
        super::super::common::v1::SearchAttributes,
    >,
    /// This value can be passed back to UpdateSchedule to ensure that the
    /// schedule was not modified between a Describe and an Update, which could
    /// lead to lost updates and other confusion.
    #[prost(bytes = "vec", tag = "5")]
    pub conflict_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateScheduleRequest {
    /// The namespace of the schedule to update.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The id of the schedule to update.
    #[prost(string, tag = "2")]
    pub schedule_id: ::prost::alloc::string::String,
    /// The new schedule. The four main fields of the schedule (spec, action,
    /// policies, state) are replaced completely by the values in this message.
    #[prost(message, optional, tag = "3")]
    pub schedule: ::core::option::Option<super::super::schedule::v1::Schedule>,
    /// This can be the value of conflict_token from a DescribeScheduleResponse,
    /// which will cause this request to fail if the schedule has been modified
    /// between the Describe and this Update.
    /// If missing, the schedule will be updated unconditionally.
    #[prost(bytes = "vec", tag = "4")]
    pub conflict_token: ::prost::alloc::vec::Vec<u8>,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
    /// A unique identifier for this update request for idempotence. Typically UUIDv4.
    #[prost(string, tag = "6")]
    pub request_id: ::prost::alloc::string::String,
    /// Schedule search attributes to be updated.
    /// Do not set this field if you do not want to update the search attributes.
    /// A non-null empty object will set the search attributes to an empty map.
    /// Note: you cannot only update the search attributes with `UpdateScheduleRequest`,
    /// you must also set the `schedule` field; otherwise, it will unset the schedule.
    #[prost(message, optional, tag = "7")]
    pub search_attributes: ::core::option::Option<
        super::super::common::v1::SearchAttributes,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateScheduleResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchScheduleRequest {
    /// The namespace of the schedule to patch.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The id of the schedule to patch.
    #[prost(string, tag = "2")]
    pub schedule_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub patch: ::core::option::Option<super::super::schedule::v1::SchedulePatch>,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
    /// A unique identifier for this update request for idempotence. Typically UUIDv4.
    #[prost(string, tag = "5")]
    pub request_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PatchScheduleResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListScheduleMatchingTimesRequest {
    /// The namespace of the schedule to query.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The id of the schedule to query.
    #[prost(string, tag = "2")]
    pub schedule_id: ::prost::alloc::string::String,
    /// Time range to query.
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListScheduleMatchingTimesResponse {
    #[prost(message, repeated, tag = "1")]
    pub start_time: ::prost::alloc::vec::Vec<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteScheduleRequest {
    /// The namespace of the schedule to delete.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The id of the schedule to delete.
    #[prost(string, tag = "2")]
    pub schedule_id: ::prost::alloc::string::String,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteScheduleResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchedulesRequest {
    /// The namespace to list schedules in.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// How many to return at once.
    #[prost(int32, tag = "2")]
    pub maximum_page_size: i32,
    /// Token to get the next page of results.
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    /// Query to filter schedules.
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchedulesResponse {
    #[prost(message, repeated, tag = "1")]
    pub schedules: ::prost::alloc::vec::Vec<
        super::super::schedule::v1::ScheduleListEntry,
    >,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountSchedulesRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Visibility query, see <https://docs.temporal.io/list-filter> for the syntax.
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountSchedulesResponse {
    /// If `query` is not grouping by any field, the count is an approximate number
    /// of schedules that match the query.
    /// If `query` is grouping by a field, the count is simply the sum of the counts
    /// of the groups returned in the response. This number can be smaller than the
    /// total number of schedules matching the query.
    #[prost(int64, tag = "1")]
    pub count: i64,
    /// Contains the groups if the request is grouping by a field.
    /// The list might not be complete, and the counts of each group is approximate.
    #[prost(message, repeated, tag = "2")]
    pub groups: ::prost::alloc::vec::Vec<count_schedules_response::AggregationGroup>,
}
/// Nested message and enum types in `CountSchedulesResponse`.
pub mod count_schedules_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AggregationGroup {
        #[prost(message, repeated, tag = "1")]
        pub group_values: ::prost::alloc::vec::Vec<
            super::super::super::common::v1::Payload,
        >,
        #[prost(int64, tag = "2")]
        pub count: i64,
    }
}
/// \[cleanup-wv-pre-release\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkerBuildIdCompatibilityRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Must be set, the task queue to apply changes to. Because all workers on a given task queue
    /// must have the same set of workflow & activity implementations, there is no reason to specify
    /// a task queue type here.
    #[prost(string, tag = "2")]
    pub task_queue: ::prost::alloc::string::String,
    #[prost(
        oneof = "update_worker_build_id_compatibility_request::Operation",
        tags = "3, 4, 5, 6, 7"
    )]
    pub operation: ::core::option::Option<
        update_worker_build_id_compatibility_request::Operation,
    >,
}
/// Nested message and enum types in `UpdateWorkerBuildIdCompatibilityRequest`.
pub mod update_worker_build_id_compatibility_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddNewCompatibleVersion {
        /// A new id to be added to an existing compatible set.
        #[prost(string, tag = "1")]
        pub new_build_id: ::prost::alloc::string::String,
        /// A build id which must already exist in the version sets known by the task queue. The new
        /// id will be stored in the set containing this id, marking it as compatible with
        /// the versions within.
        #[prost(string, tag = "2")]
        pub existing_compatible_build_id: ::prost::alloc::string::String,
        /// When set, establishes the compatible set being targeted as the overall default for the
        /// queue. If a different set was the current default, the targeted set will replace it as
        /// the new default.
        #[prost(bool, tag = "3")]
        pub make_set_default: bool,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MergeSets {
        /// A build ID in the set whose default will become the merged set default
        #[prost(string, tag = "1")]
        pub primary_set_build_id: ::prost::alloc::string::String,
        /// A build ID in the set which will be merged into the primary set
        #[prost(string, tag = "2")]
        pub secondary_set_build_id: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// A new build id. This operation will create a new set which will be the new overall
        /// default version for the queue, with this id as its only member. This new set is
        /// incompatible with all previous sets/versions.
        ///
        /// (-- api-linter: core::0140::prepositions=disabled
        ///      aip.dev/not-precedent: In makes perfect sense here. --)
        #[prost(string, tag = "3")]
        AddNewBuildIdInNewDefaultSet(::prost::alloc::string::String),
        /// Adds a new id to an existing compatible set, see sub-message definition for more.
        #[prost(message, tag = "4")]
        AddNewCompatibleBuildId(AddNewCompatibleVersion),
        /// Promote an existing set to be the current default (if it isn't already) by targeting
        /// an existing build id within it. This field's value is the extant build id.
        ///
        /// (-- api-linter: core::0140::prepositions=disabled
        ///      aip.dev/not-precedent: Names are hard. --)
        #[prost(string, tag = "5")]
        PromoteSetByBuildId(::prost::alloc::string::String),
        /// Promote an existing build id within some set to be the current default for that set.
        ///
        /// (-- api-linter: core::0140::prepositions=disabled
        ///      aip.dev/not-precedent: Within makes perfect sense here. --)
        #[prost(string, tag = "6")]
        PromoteBuildIdWithinSet(::prost::alloc::string::String),
        /// Merge two existing sets together, thus declaring all build IDs in both sets compatible
        /// with one another. The primary set's default will become the default for the merged set.
        /// This is useful if you've accidentally declared a new ID as incompatible you meant to
        /// declare as compatible. The unusual case of incomplete replication during failover could
        /// also result in a split set, which this operation can repair.
        #[prost(message, tag = "7")]
        MergeSets(MergeSets),
    }
}
/// \[cleanup-wv-pre-release\]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateWorkerBuildIdCompatibilityResponse {}
/// \[cleanup-wv-pre-release\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkerBuildIdCompatibilityRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Must be set, the task queue to interrogate about worker id compatibility.
    #[prost(string, tag = "2")]
    pub task_queue: ::prost::alloc::string::String,
    /// Limits how many compatible sets will be returned. Specify 1 to only return the current
    /// default major version set. 0 returns all sets.
    #[prost(int32, tag = "3")]
    pub max_sets: i32,
}
/// \[cleanup-wv-pre-release\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkerBuildIdCompatibilityResponse {
    /// Major version sets, in order from oldest to newest. The last element of the list will always
    /// be the current default major version. IE: New workflows will target the most recent version
    /// in that version set.
    ///
    /// There may be fewer sets returned than exist, if the request chose to limit this response.
    #[prost(message, repeated, tag = "1")]
    pub major_version_sets: ::prost::alloc::vec::Vec<
        super::super::taskqueue::v1::CompatibleVersionSet,
    >,
}
/// (-- api-linter: core::0134::request-mask-required=disabled
///      aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
/// (-- api-linter: core::0134::request-resource-required=disabled
///      aip.dev/not-precedent: GetWorkerBuildIdCompatibilityRequest RPC doesn't follow Google API format. --)
/// \[cleanup-wv-pre-release\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkerVersioningRulesRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub task_queue: ::prost::alloc::string::String,
    /// A valid conflict_token can be taken from the previous
    /// ListWorkerVersioningRulesResponse or UpdateWorkerVersioningRulesResponse.
    /// An invalid token will cause this request to fail, ensuring that if the rules
    /// for this Task Queue have been modified between the previous and current
    /// operation, the request will fail instead of causing an unpredictable mutation.
    #[prost(bytes = "vec", tag = "3")]
    pub conflict_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(
        oneof = "update_worker_versioning_rules_request::Operation",
        tags = "4, 5, 6, 7, 8, 9, 10"
    )]
    pub operation: ::core::option::Option<
        update_worker_versioning_rules_request::Operation,
    >,
}
/// Nested message and enum types in `UpdateWorkerVersioningRulesRequest`.
pub mod update_worker_versioning_rules_request {
    /// Inserts the rule to the list of assignment rules for this Task Queue.
    /// The rules are evaluated in order, starting from index 0. The first
    /// applicable rule will be applied and the rest will be ignored.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InsertBuildIdAssignmentRule {
        /// Use this option to insert the rule in a particular index. By
        /// default, the new rule is inserted at the beginning of the list
        /// (index 0). If the given index is too larger the rule will be
        /// inserted at the end of the list.
        #[prost(int32, tag = "1")]
        pub rule_index: i32,
        #[prost(message, optional, tag = "2")]
        pub rule: ::core::option::Option<
            super::super::super::taskqueue::v1::BuildIdAssignmentRule,
        >,
    }
    /// Replaces the assignment rule at a given index.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReplaceBuildIdAssignmentRule {
        #[prost(int32, tag = "1")]
        pub rule_index: i32,
        #[prost(message, optional, tag = "2")]
        pub rule: ::core::option::Option<
            super::super::super::taskqueue::v1::BuildIdAssignmentRule,
        >,
        /// By default presence of one unconditional rule is enforced, otherwise
        /// the replace operation will be rejected. Set `force` to true to
        /// bypass this validation. An unconditional assignment rule:
        ///    - Has no hint filter
        ///    - Has no ramp
        #[prost(bool, tag = "3")]
        pub force: bool,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DeleteBuildIdAssignmentRule {
        #[prost(int32, tag = "1")]
        pub rule_index: i32,
        /// By default presence of one unconditional rule is enforced, otherwise
        /// the delete operation will be rejected. Set `force` to true to
        /// bypass this validation. An unconditional assignment rule:
        ///    - Has no hint filter
        ///    - Has no ramp
        #[prost(bool, tag = "2")]
        pub force: bool,
    }
    /// Adds the rule to the list of redirect rules for this Task Queue. There
    /// can be at most one redirect rule for each distinct Source Build ID.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddCompatibleBuildIdRedirectRule {
        #[prost(message, optional, tag = "1")]
        pub rule: ::core::option::Option<
            super::super::super::taskqueue::v1::CompatibleBuildIdRedirectRule,
        >,
    }
    /// Replaces the routing rule with the given source Build ID.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReplaceCompatibleBuildIdRedirectRule {
        #[prost(message, optional, tag = "1")]
        pub rule: ::core::option::Option<
            super::super::super::taskqueue::v1::CompatibleBuildIdRedirectRule,
        >,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeleteCompatibleBuildIdRedirectRule {
        #[prost(string, tag = "1")]
        pub source_build_id: ::prost::alloc::string::String,
    }
    /// This command is intended to be used to complete the rollout of a Build
    /// ID and cleanup unnecessary rules possibly created during a gradual
    /// rollout. Specifically, this command will make the following changes
    /// atomically:
    ///   1. Adds an assignment rule (with full ramp) for the target Build ID at
    ///      the end of the list.
    ///   2. Removes all previously added assignment rules to the given target
    ///      Build ID (if any).
    ///   3. Removes any fully-ramped assignment rule for other Build IDs.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CommitBuildId {
        #[prost(string, tag = "1")]
        pub target_build_id: ::prost::alloc::string::String,
        /// To prevent committing invalid Build IDs, we reject the request if no
        /// pollers has been seen recently for this Build ID. Use the `force`
        /// option to disable this validation.
        #[prost(bool, tag = "2")]
        pub force: bool,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        #[prost(message, tag = "4")]
        InsertAssignmentRule(InsertBuildIdAssignmentRule),
        #[prost(message, tag = "5")]
        ReplaceAssignmentRule(ReplaceBuildIdAssignmentRule),
        #[prost(message, tag = "6")]
        DeleteAssignmentRule(DeleteBuildIdAssignmentRule),
        #[prost(message, tag = "7")]
        AddCompatibleRedirectRule(AddCompatibleBuildIdRedirectRule),
        #[prost(message, tag = "8")]
        ReplaceCompatibleRedirectRule(ReplaceCompatibleBuildIdRedirectRule),
        #[prost(message, tag = "9")]
        DeleteCompatibleRedirectRule(DeleteCompatibleBuildIdRedirectRule),
        #[prost(message, tag = "10")]
        CommitBuildId(CommitBuildId),
    }
}
/// \[cleanup-wv-pre-release\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkerVersioningRulesResponse {
    #[prost(message, repeated, tag = "1")]
    pub assignment_rules: ::prost::alloc::vec::Vec<
        super::super::taskqueue::v1::TimestampedBuildIdAssignmentRule,
    >,
    #[prost(message, repeated, tag = "2")]
    pub compatible_redirect_rules: ::prost::alloc::vec::Vec<
        super::super::taskqueue::v1::TimestampedCompatibleBuildIdRedirectRule,
    >,
    /// This value can be passed back to UpdateWorkerVersioningRulesRequest to
    /// ensure that the rules were not modified between the two updates, which
    /// could lead to lost updates and other confusion.
    #[prost(bytes = "vec", tag = "3")]
    pub conflict_token: ::prost::alloc::vec::Vec<u8>,
}
/// \[cleanup-wv-pre-release\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkerVersioningRulesRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub task_queue: ::prost::alloc::string::String,
}
/// \[cleanup-wv-pre-release\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkerVersioningRulesResponse {
    #[prost(message, repeated, tag = "1")]
    pub assignment_rules: ::prost::alloc::vec::Vec<
        super::super::taskqueue::v1::TimestampedBuildIdAssignmentRule,
    >,
    #[prost(message, repeated, tag = "2")]
    pub compatible_redirect_rules: ::prost::alloc::vec::Vec<
        super::super::taskqueue::v1::TimestampedCompatibleBuildIdRedirectRule,
    >,
    /// This value can be passed back to UpdateWorkerVersioningRulesRequest to
    /// ensure that the rules were not modified between this List and the Update,
    /// which could lead to lost updates and other confusion.
    #[prost(bytes = "vec", tag = "3")]
    pub conflict_token: ::prost::alloc::vec::Vec<u8>,
}
/// \[cleanup-wv-pre-release\]
/// Deprecated. Use `DescribeTaskQueue`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkerTaskReachabilityRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.
    /// The number of build ids that can be queried in a single API call is limited.
    /// Open source users can adjust this limit by setting the server's dynamic config value for
    /// `limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.
    #[prost(string, repeated, tag = "2")]
    pub build_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given
    /// build ids in the namespace.
    /// Must specify at least one task queue if querying for an unversioned worker.
    /// The number of task queues that the server will fetch reachability information for is limited.
    /// See the `GetWorkerTaskReachabilityResponse` documentation for more information.
    #[prost(string, repeated, tag = "3")]
    pub task_queues: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Type of reachability to query for.
    /// `TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.
    /// Use `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.
    /// Otherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left
    /// unspecified.
    /// See the TaskReachability docstring for information about each enum variant.
    #[prost(enumeration = "super::super::enums::v1::TaskReachability", tag = "4")]
    pub reachability: i32,
}
/// \[cleanup-wv-pre-release\]
/// Deprecated. Use `DescribeTaskQueue`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkerTaskReachabilityResponse {
    /// Task reachability, broken down by build id and then task queue.
    /// When requesting a large number of task queues or all task queues associated with the given build ids in a
    /// namespace, all task queues will be listed in the response but some of them may not contain reachability
    /// information due to a server enforced limit. When reaching the limit, task queues that reachability information
    /// could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
    /// another call to get the reachability for those task queues.
    ///
    /// Open source users can adjust this limit by setting the server's dynamic config value for
    /// `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
    #[prost(message, repeated, tag = "1")]
    pub build_id_reachability: ::prost::alloc::vec::Vec<
        super::super::taskqueue::v1::BuildIdReachability,
    >,
}
/// (-- api-linter: core::0134=disabled
///      aip.dev/not-precedent: Update RPCs don't follow Google API format. --)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkflowExecutionRequest {
    /// The namespace name of the target Workflow.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The target Workflow Id and (optionally) a specific Run Id thereof.
    /// (-- api-linter: core::0203::optional=disabled
    ///      aip.dev/not-precedent: false positive triggered by the word "optional" --)
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<
        super::super::common::v1::WorkflowExecution,
    >,
    /// If set, this call will error if the most recent (if no Run Id is set on
    /// `workflow_execution`), or specified (if it is) Workflow Execution is not
    /// part of the same execution chain as this Id.
    #[prost(string, tag = "3")]
    pub first_execution_run_id: ::prost::alloc::string::String,
    /// Specifies client's intent to wait for Update results.
    /// NOTE: This field works together with API call timeout which is limited by
    /// server timeout (maximum wait time). If server timeout is expired before
    /// user specified timeout, API call returns even if specified stage is not reached.
    /// Actual reached stage will be included in the response.
    #[prost(message, optional, tag = "4")]
    pub wait_policy: ::core::option::Option<super::super::update::v1::WaitPolicy>,
    /// The request information that will be delivered all the way down to the
    /// Workflow Execution.
    #[prost(message, optional, tag = "5")]
    pub request: ::core::option::Option<super::super::update::v1::Request>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkflowExecutionResponse {
    /// Enough information for subsequent poll calls if needed. Never null.
    #[prost(message, optional, tag = "1")]
    pub update_ref: ::core::option::Option<super::super::update::v1::UpdateRef>,
    /// The outcome of the Update if and only if the Workflow Update
    /// has completed. If this response is being returned before the Update has
    /// completed then this field will not be set.
    #[prost(message, optional, tag = "2")]
    pub outcome: ::core::option::Option<super::super::update::v1::Outcome>,
    /// The most advanced lifecycle stage that the Update is known to have
    /// reached, where lifecycle stages are ordered
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
    /// UNSPECIFIED will be returned if and only if the server's maximum wait
    /// time was reached before the Update reached the stage specified in the
    /// request WaitPolicy, and before the context deadline expired; clients may
    /// may then retry the call as needed.
    #[prost(
        enumeration = "super::super::enums::v1::UpdateWorkflowExecutionLifecycleStage",
        tag = "3"
    )]
    pub stage: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartBatchOperationRequest {
    /// Namespace that contains the batch operation
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Visibility query defines the the group of workflow to apply the batch operation
    /// This field and `executions` are mutually exclusive
    #[prost(string, tag = "2")]
    pub visibility_query: ::prost::alloc::string::String,
    /// Job ID defines the unique ID for the batch job
    #[prost(string, tag = "3")]
    pub job_id: ::prost::alloc::string::String,
    /// Reason to perform the batch operation
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
    /// Executions to apply the batch operation
    /// This field and `visibility_query` are mutually exclusive
    #[prost(message, repeated, tag = "5")]
    pub executions: ::prost::alloc::vec::Vec<
        super::super::common::v1::WorkflowExecution,
    >,
    /// Limit for the number of operations processed per second within this batch.
    /// Its purpose is to reduce the stress on the system caused by batch operations, which helps to prevent system
    /// overload and minimize potential delays in executing ongoing tasks for user workers.
    /// Note that when no explicit limit is provided, the server will operate according to its limit defined by the
    /// dynamic configuration key `worker.batcherRPS`. This also applies if the value in this field exceeds the
    /// server's configured limit.
    #[prost(float, tag = "6")]
    pub max_operations_per_second: f32,
    /// Operation input
    #[prost(
        oneof = "start_batch_operation_request::Operation",
        tags = "10, 11, 12, 13, 14, 15, 16, 17, 18"
    )]
    pub operation: ::core::option::Option<start_batch_operation_request::Operation>,
}
/// Nested message and enum types in `StartBatchOperationRequest`.
pub mod start_batch_operation_request {
    /// Operation input
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        #[prost(message, tag = "10")]
        TerminationOperation(super::super::super::batch::v1::BatchOperationTermination),
        #[prost(message, tag = "11")]
        SignalOperation(super::super::super::batch::v1::BatchOperationSignal),
        #[prost(message, tag = "12")]
        CancellationOperation(
            super::super::super::batch::v1::BatchOperationCancellation,
        ),
        #[prost(message, tag = "13")]
        DeletionOperation(super::super::super::batch::v1::BatchOperationDeletion),
        #[prost(message, tag = "14")]
        ResetOperation(super::super::super::batch::v1::BatchOperationReset),
        #[prost(message, tag = "15")]
        UpdateWorkflowOptionsOperation(
            super::super::super::batch::v1::BatchOperationUpdateWorkflowExecutionOptions,
        ),
        #[prost(message, tag = "16")]
        UnpauseActivitiesOperation(
            super::super::super::batch::v1::BatchOperationUnpauseActivities,
        ),
        #[prost(message, tag = "17")]
        ResetActivitiesOperation(
            super::super::super::batch::v1::BatchOperationResetActivities,
        ),
        #[prost(message, tag = "18")]
        UpdateActivityOptionsOperation(
            super::super::super::batch::v1::BatchOperationUpdateActivityOptions,
        ),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartBatchOperationResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopBatchOperationRequest {
    /// Namespace that contains the batch operation
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Batch job id
    #[prost(string, tag = "2")]
    pub job_id: ::prost::alloc::string::String,
    /// Reason to stop a batch operation
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
    /// Identity of the operator
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StopBatchOperationResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeBatchOperationRequest {
    /// Namespace that contains the batch operation
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Batch job id
    #[prost(string, tag = "2")]
    pub job_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeBatchOperationResponse {
    /// Batch operation type
    #[prost(enumeration = "super::super::enums::v1::BatchOperationType", tag = "1")]
    pub operation_type: i32,
    /// Batch job ID
    #[prost(string, tag = "2")]
    pub job_id: ::prost::alloc::string::String,
    /// Batch operation state
    #[prost(enumeration = "super::super::enums::v1::BatchOperationState", tag = "3")]
    pub state: i32,
    /// Batch operation start time
    #[prost(message, optional, tag = "4")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Batch operation close time
    #[prost(message, optional, tag = "5")]
    pub close_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Total operation count
    #[prost(int64, tag = "6")]
    pub total_operation_count: i64,
    /// Complete operation count
    #[prost(int64, tag = "7")]
    pub complete_operation_count: i64,
    /// Failure operation count
    #[prost(int64, tag = "8")]
    pub failure_operation_count: i64,
    /// Identity indicates the operator identity
    #[prost(string, tag = "9")]
    pub identity: ::prost::alloc::string::String,
    /// Reason indicates the reason to stop a operation
    #[prost(string, tag = "10")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBatchOperationsRequest {
    /// Namespace that contains the batch operation
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// List page size
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Next page token
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBatchOperationsResponse {
    /// BatchOperationInfo contains the basic info about batch operation
    #[prost(message, repeated, tag = "1")]
    pub operation_info: ::prost::alloc::vec::Vec<
        super::super::batch::v1::BatchOperationInfo,
    >,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollWorkflowExecutionUpdateRequest {
    /// The namespace of the Workflow Execution to which the Update was
    /// originally issued.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The Update reference returned in the initial UpdateWorkflowExecutionResponse.
    #[prost(message, optional, tag = "2")]
    pub update_ref: ::core::option::Option<super::super::update::v1::UpdateRef>,
    /// The identity of the worker/client who is polling this Update outcome.
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    /// Specifies client's intent to wait for Update results.
    /// Omit to request a non-blocking poll.
    #[prost(message, optional, tag = "4")]
    pub wait_policy: ::core::option::Option<super::super::update::v1::WaitPolicy>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollWorkflowExecutionUpdateResponse {
    /// The outcome of the update if and only if the update has completed. If
    /// this response is being returned before the update has completed (e.g. due
    /// to the specification of a wait policy that only waits on
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED) then this field will
    /// not be set.
    #[prost(message, optional, tag = "1")]
    pub outcome: ::core::option::Option<super::super::update::v1::Outcome>,
    /// The most advanced lifecycle stage that the Update is known to have
    /// reached, where lifecycle stages are ordered
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
    /// UNSPECIFIED will be returned if and only if the server's maximum wait
    /// time was reached before the Update reached the stage specified in the
    /// request WaitPolicy, and before the context deadline expired; clients may
    /// may then retry the call as needed.
    #[prost(
        enumeration = "super::super::enums::v1::UpdateWorkflowExecutionLifecycleStage",
        tag = "2"
    )]
    pub stage: i32,
    /// Sufficient information to address this Update.
    #[prost(message, optional, tag = "3")]
    pub update_ref: ::core::option::Option<super::super::update::v1::UpdateRef>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollNexusTaskQueueRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "2")]
    pub identity: ::prost::alloc::string::String,
    /// A unique key for this worker instance, used for tracking worker lifecycle.
    /// This is guaranteed to be unique, whereas identity is not guaranteed to be unique.
    #[prost(string, tag = "8")]
    pub worker_instance_key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub task_queue: ::core::option::Option<super::super::taskqueue::v1::TaskQueue>,
    /// Information about this worker's build identifier and if it is choosing to use the versioning
    /// feature. See the `WorkerVersionCapabilities` docstring for more.
    /// Deprecated. Replaced by deployment_options.
    #[deprecated]
    #[prost(message, optional, tag = "4")]
    pub worker_version_capabilities: ::core::option::Option<
        super::super::common::v1::WorkerVersionCapabilities,
    >,
    /// Worker deployment options that user has set in the worker.
    #[prost(message, optional, tag = "6")]
    pub deployment_options: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentOptions,
    >,
    /// Worker info to be sent to the server.
    #[prost(message, repeated, tag = "7")]
    pub worker_heartbeat: ::prost::alloc::vec::Vec<
        super::super::worker::v1::WorkerHeartbeat,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollNexusTaskQueueResponse {
    /// An opaque unique identifier for this task for correlating a completion request the embedded request.
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    /// Embedded request as translated from the incoming frontend request.
    #[prost(message, optional, tag = "2")]
    pub request: ::core::option::Option<super::super::nexus::v1::Request>,
    /// Server-advised information the SDK may use to adjust its poller count.
    #[prost(message, optional, tag = "3")]
    pub poller_scaling_decision: ::core::option::Option<
        super::super::taskqueue::v1::PollerScalingDecision,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondNexusTaskCompletedRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "2")]
    pub identity: ::prost::alloc::string::String,
    /// A unique identifier for this task as received via a poll response.
    #[prost(bytes = "vec", tag = "3")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    /// Embedded response to be translated into a frontend response.
    #[prost(message, optional, tag = "4")]
    pub response: ::core::option::Option<super::super::nexus::v1::Response>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondNexusTaskCompletedResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondNexusTaskFailedRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "2")]
    pub identity: ::prost::alloc::string::String,
    /// A unique identifier for this task.
    #[prost(bytes = "vec", tag = "3")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    /// The error the handler failed with.
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<super::super::nexus::v1::HandlerError>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondNexusTaskFailedResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteMultiOperationRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// List of operations to execute within a single workflow.
    ///
    /// Preconditions:
    /// - The list of operations must not be empty.
    /// - The workflow ids must match across operations.
    /// - The only valid list of operations at this time is \[StartWorkflow, UpdateWorkflow\], in this order.
    ///
    /// Note that additional operation-specific restrictions have to be considered.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<execute_multi_operation_request::Operation>,
}
/// Nested message and enum types in `ExecuteMultiOperationRequest`.
pub mod execute_multi_operation_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Operation {
        #[prost(oneof = "operation::Operation", tags = "1, 2")]
        pub operation: ::core::option::Option<operation::Operation>,
    }
    /// Nested message and enum types in `Operation`.
    pub mod operation {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Operation {
            /// Additional restrictions:
            /// - setting `cron_schedule` is invalid
            /// - setting `request_eager_execution` is invalid
            /// - setting `workflow_start_delay` is invalid
            #[prost(message, tag = "1")]
            StartWorkflow(super::super::StartWorkflowExecutionRequest),
            /// Additional restrictions:
            /// - setting `first_execution_run_id` is invalid
            /// - setting `workflow_execution.run_id` is invalid
            #[prost(message, tag = "2")]
            UpdateWorkflow(super::super::UpdateWorkflowExecutionRequest),
        }
    }
}
/// IMPORTANT: For \[StartWorkflow, UpdateWorkflow\] combination ("Update-with-Start") when both
///    1. the workflow update for the requested update ID has already completed, and
///    2. the workflow for the requested workflow ID has already been closed,
/// then you'll receive
///    - an update response containing the update's outcome, and
///    - a start response with a `status` field that reflects the workflow's current state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteMultiOperationResponse {
    #[prost(message, repeated, tag = "1")]
    pub responses: ::prost::alloc::vec::Vec<execute_multi_operation_response::Response>,
}
/// Nested message and enum types in `ExecuteMultiOperationResponse`.
pub mod execute_multi_operation_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(oneof = "response::Response", tags = "1, 2")]
        pub response: ::core::option::Option<response::Response>,
    }
    /// Nested message and enum types in `Response`.
    pub mod response {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Response {
            #[prost(message, tag = "1")]
            StartWorkflow(super::super::StartWorkflowExecutionResponse),
            #[prost(message, tag = "2")]
            UpdateWorkflow(super::super::UpdateWorkflowExecutionResponse),
        }
    }
}
/// NOTE: keep in sync with temporal.api.batch.v1.BatchOperationUpdateActivityOptions
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateActivityOptionsRequest {
    /// Namespace of the workflow which scheduled this activity
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Execution info of the workflow which scheduled this activity
    #[prost(message, optional, tag = "2")]
    pub execution: ::core::option::Option<super::super::common::v1::WorkflowExecution>,
    /// The identity of the client who initiated this request
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    /// Activity options. Partial updates are accepted and controlled by update_mask
    #[prost(message, optional, tag = "4")]
    pub activity_options: ::core::option::Option<
        super::super::activity::v1::ActivityOptions,
    >,
    /// Controls which fields from `activity_options` will be applied
    #[prost(message, optional, tag = "5")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// If set, the activity options will be restored to the default.
    /// Default options are then options activity was created with.
    /// They are part of the first SCHEDULE event.
    /// This flag cannot be combined with any other option; if you supply
    /// restore_original together with other options, the request will be rejected.
    #[prost(bool, tag = "8")]
    pub restore_original: bool,
    /// either activity id, activity type or update_all must be provided
    #[prost(oneof = "update_activity_options_request::Activity", tags = "6, 7, 9")]
    pub activity: ::core::option::Option<update_activity_options_request::Activity>,
}
/// Nested message and enum types in `UpdateActivityOptionsRequest`.
pub mod update_activity_options_request {
    /// either activity id, activity type or update_all must be provided
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Activity {
        /// Only activity with this ID will be updated.
        #[prost(string, tag = "6")]
        Id(::prost::alloc::string::String),
        /// Update all running activities of this type.
        #[prost(string, tag = "7")]
        Type(::prost::alloc::string::String),
        /// Update all running activities.
        #[prost(bool, tag = "9")]
        MatchAll(bool),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateActivityOptionsResponse {
    /// Activity options after an update
    #[prost(message, optional, tag = "1")]
    pub activity_options: ::core::option::Option<
        super::super::activity::v1::ActivityOptions,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseActivityRequest {
    /// Namespace of the workflow which scheduled this activity.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Execution info of the workflow which scheduled this activity
    #[prost(message, optional, tag = "2")]
    pub execution: ::core::option::Option<super::super::common::v1::WorkflowExecution>,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    /// Reason to pause the activity.
    #[prost(string, tag = "6")]
    pub reason: ::prost::alloc::string::String,
    /// either activity id or activity type must be provided
    #[prost(oneof = "pause_activity_request::Activity", tags = "4, 5")]
    pub activity: ::core::option::Option<pause_activity_request::Activity>,
}
/// Nested message and enum types in `PauseActivityRequest`.
pub mod pause_activity_request {
    /// either activity id or activity type must be provided
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Activity {
        /// Only the activity with this ID will be paused.
        #[prost(string, tag = "4")]
        Id(::prost::alloc::string::String),
        /// Pause all running activities of this type.
        /// Note: Experimental - the behavior of pause by activity type might change in a future release.
        #[prost(string, tag = "5")]
        Type(::prost::alloc::string::String),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PauseActivityResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnpauseActivityRequest {
    /// Namespace of the workflow which scheduled this activity.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Execution info of the workflow which scheduled this activity
    #[prost(message, optional, tag = "2")]
    pub execution: ::core::option::Option<super::super::common::v1::WorkflowExecution>,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    /// Providing this flag will also reset the number of attempts.
    #[prost(bool, tag = "7")]
    pub reset_attempts: bool,
    /// Providing this flag will also reset the heartbeat details.
    #[prost(bool, tag = "8")]
    pub reset_heartbeat: bool,
    /// If set, the activity will start at a random time within the specified jitter duration.
    #[prost(message, optional, tag = "9")]
    pub jitter: ::core::option::Option<::prost_types::Duration>,
    /// either activity id or activity type must be provided
    #[prost(oneof = "unpause_activity_request::Activity", tags = "4, 5, 6")]
    pub activity: ::core::option::Option<unpause_activity_request::Activity>,
}
/// Nested message and enum types in `UnpauseActivityRequest`.
pub mod unpause_activity_request {
    /// either activity id or activity type must be provided
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Activity {
        /// Only the activity with this ID will be unpaused.
        #[prost(string, tag = "4")]
        Id(::prost::alloc::string::String),
        /// Unpause all running activities with of this type.
        #[prost(string, tag = "5")]
        Type(::prost::alloc::string::String),
        /// Unpause all running activities.
        #[prost(bool, tag = "6")]
        UnpauseAll(bool),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnpauseActivityResponse {}
/// NOTE: keep in sync with temporal.api.batch.v1.BatchOperationResetActivities
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetActivityRequest {
    /// Namespace of the workflow which scheduled this activity.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Execution info of the workflow which scheduled this activity
    #[prost(message, optional, tag = "2")]
    pub execution: ::core::option::Option<super::super::common::v1::WorkflowExecution>,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    /// Indicates that activity should reset heartbeat details.
    /// This flag will be applied only to the new instance of the activity.
    #[prost(bool, tag = "6")]
    pub reset_heartbeat: bool,
    /// If activity is paused, it will remain paused after reset
    #[prost(bool, tag = "7")]
    pub keep_paused: bool,
    /// If set, and activity is in backoff, the activity will start at a random time within the specified jitter duration.
    /// (unless it is paused and keep_paused is set)
    #[prost(message, optional, tag = "8")]
    pub jitter: ::core::option::Option<::prost_types::Duration>,
    /// If set, the activity options will be restored to the defaults.
    /// Default options are then options activity was created with.
    /// They are part of the first SCHEDULE event.
    #[prost(bool, tag = "9")]
    pub restore_original_options: bool,
    /// either activity id, activity type or update_all must be provided
    #[prost(oneof = "reset_activity_request::Activity", tags = "4, 5, 10")]
    pub activity: ::core::option::Option<reset_activity_request::Activity>,
}
/// Nested message and enum types in `ResetActivityRequest`.
pub mod reset_activity_request {
    /// either activity id, activity type or update_all must be provided
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Activity {
        /// Only activity with this ID will be reset.
        #[prost(string, tag = "4")]
        Id(::prost::alloc::string::String),
        /// Reset all running activities with of this type.
        #[prost(string, tag = "5")]
        Type(::prost::alloc::string::String),
        /// Reset all running activities.
        #[prost(bool, tag = "10")]
        MatchAll(bool),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResetActivityResponse {}
/// Keep the parameters in sync with:
///    - temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions.
///    - temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkflowExecutionOptionsRequest {
    /// The namespace name of the target Workflow.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The target Workflow Id and (optionally) a specific Run Id thereof.
    /// (-- api-linter: core::0203::optional=disabled
    ///      aip.dev/not-precedent: false positive triggered by the word "optional" --)
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<
        super::super::common::v1::WorkflowExecution,
    >,
    /// Workflow Execution options. Partial updates are accepted and controlled by update_mask.
    #[prost(message, optional, tag = "3")]
    pub workflow_execution_options: ::core::option::Option<
        super::super::workflow::v1::WorkflowExecutionOptions,
    >,
    /// Controls which fields from `workflow_execution_options` will be applied.
    /// To unset a field, set it to null and use the update mask to indicate that it should be mutated.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Optional. The identity of the client who initiated this request.
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkflowExecutionOptionsResponse {
    /// Workflow Execution options after update.
    #[prost(message, optional, tag = "1")]
    pub workflow_execution_options: ::core::option::Option<
        super::super::workflow::v1::WorkflowExecutionOptions,
    >,
}
/// \[cleanup-wv-pre-release\] Pre-release deployment APIs, clean up later
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeDeploymentRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub deployment: ::core::option::Option<super::super::deployment::v1::Deployment>,
}
/// \[cleanup-wv-pre-release\] Pre-release deployment APIs, clean up later
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeDeploymentResponse {
    #[prost(message, optional, tag = "1")]
    pub deployment_info: ::core::option::Option<
        super::super::deployment::v1::DeploymentInfo,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeWorkerDeploymentVersionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Deprecated. Use `deployment_version`.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Required.
    #[prost(message, optional, tag = "3")]
    pub deployment_version: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentVersion,
    >,
    /// Report stats for task queues which have been polled by this version.
    #[prost(bool, tag = "4")]
    pub report_task_queue_stats: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeWorkerDeploymentVersionResponse {
    #[prost(message, optional, tag = "1")]
    pub worker_deployment_version_info: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentVersionInfo,
    >,
    /// All the Task Queues that have ever polled from this Deployment version.
    #[prost(message, repeated, tag = "2")]
    pub version_task_queues: ::prost::alloc::vec::Vec<
        describe_worker_deployment_version_response::VersionTaskQueue,
    >,
}
/// Nested message and enum types in `DescribeWorkerDeploymentVersionResponse`.
pub mod describe_worker_deployment_version_response {
    /// (-- api-linter: core::0123::resource-annotation=disabled --)
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VersionTaskQueue {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(
            enumeration = "super::super::super::enums::v1::TaskQueueType",
            tag = "2"
        )]
        pub r#type: i32,
        /// Only set if `report_task_queue_stats` is set on the request.
        #[prost(message, optional, tag = "3")]
        pub stats: ::core::option::Option<
            super::super::super::taskqueue::v1::TaskQueueStats,
        >,
        /// Task queue stats breakdown by priority key. Only contains actively used priority keys.
        /// Only set if `report_task_queue_stats` is set to true in the request.
        /// (-- api-linter: core::0140::prepositions=disabled
        ///      aip.dev/not-precedent: "by" is used to clarify the key. --)
        #[prost(map = "int32, message", tag = "4")]
        pub stats_by_priority_key: ::std::collections::HashMap<
            i32,
            super::super::super::taskqueue::v1::TaskQueueStats,
        >,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeWorkerDeploymentRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployment_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeWorkerDeploymentResponse {
    /// This value is returned so that it can be optionally passed to APIs
    /// that write to the Worker Deployment state to ensure that the state
    /// did not change between this read and a future write.
    #[prost(bytes = "vec", tag = "1")]
    pub conflict_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub worker_deployment_info: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentInfo,
    >,
}
/// \[cleanup-wv-pre-release\] Pre-release deployment APIs, clean up later
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    /// Optional. Use to filter based on exact series name match.
    #[prost(string, tag = "4")]
    pub series_name: ::prost::alloc::string::String,
}
/// \[cleanup-wv-pre-release\] Pre-release deployment APIs, clean up later
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub deployments: ::prost::alloc::vec::Vec<
        super::super::deployment::v1::DeploymentListInfo,
    >,
}
/// \[cleanup-wv-pre-release\] Pre-release deployment APIs, clean up later
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCurrentDeploymentRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub deployment: ::core::option::Option<super::super::deployment::v1::Deployment>,
    /// Optional. The identity of the client who initiated this request.
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    /// Optional. Use to add or remove user-defined metadata entries. Metadata entries are exposed
    /// when describing a deployment. It is a good place for information such as operator name,
    /// links to internal deployment pipelines, etc.
    #[prost(message, optional, tag = "4")]
    pub update_metadata: ::core::option::Option<
        super::super::deployment::v1::UpdateDeploymentMetadata,
    >,
}
/// \[cleanup-wv-pre-release\] Pre-release deployment APIs, clean up later
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCurrentDeploymentResponse {
    #[prost(message, optional, tag = "1")]
    pub current_deployment_info: ::core::option::Option<
        super::super::deployment::v1::DeploymentInfo,
    >,
    /// Info of the deployment that was current before executing this operation.
    #[prost(message, optional, tag = "2")]
    pub previous_deployment_info: ::core::option::Option<
        super::super::deployment::v1::DeploymentInfo,
    >,
}
/// Set/unset the Current Version of a Worker Deployment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetWorkerDeploymentCurrentVersionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployment_name: ::prost::alloc::string::String,
    /// Deprecated. Use `build_id`.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The build id of the Version that you want to set as Current.
    /// Pass an empty value to set the Current Version to nil.
    /// A nil Current Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
    #[prost(string, tag = "7")]
    pub build_id: ::prost::alloc::string::String,
    /// Optional. This can be the value of conflict_token from a Describe, or another Worker
    /// Deployment API. Passing a non-nil conflict token will cause this request to fail if the
    /// Deployment's configuration has been modified between the API call that generated the
    /// token and this one.
    #[prost(bytes = "vec", tag = "4")]
    pub conflict_token: ::prost::alloc::vec::Vec<u8>,
    /// Optional. The identity of the client who initiated this request.
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
    /// Optional. By default this request would be rejected if not all the expected Task Queues are
    /// being polled by the new Version, to protect against accidental removal of Task Queues, or
    /// worker health issues. Pass `true` here to bypass this protection.
    /// The set of expected Task Queues is the set of all the Task Queues that were ever poller by
    /// the existing Current Version of the Deployment, with the following exclusions:
    ///    - Task Queues that are not used anymore (inferred by having empty backlog and a task
    ///      add_rate of 0.)
    ///    - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
    ///      having a different Current Version than the Current Version of this deployment.)
    /// WARNING: Do not set this flag unless you are sure that the missing task queue pollers are not
    /// needed. If the request is unexpectedly rejected due to missing pollers, then that means the
    /// pollers have not reached to the server yet. Only set this if you expect those pollers to
    /// never arrive.
    #[prost(bool, tag = "6")]
    pub ignore_missing_task_queues: bool,
    /// Optional. By default this request will be rejected if no pollers have been seen for the proposed
    /// Current Version, in order to protect users from routing tasks to pollers that do not exist, leading
    /// to possible timeouts. Pass `true` here to bypass this protection.
    #[prost(bool, tag = "9")]
    pub allow_no_pollers: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetWorkerDeploymentCurrentVersionResponse {
    /// This value is returned so that it can be optionally passed to APIs
    /// that write to the Worker Deployment state to ensure that the state
    /// did not change between this API call and a future write.
    #[prost(bytes = "vec", tag = "1")]
    pub conflict_token: ::prost::alloc::vec::Vec<u8>,
    /// Deprecated. Use `previous_deployment_version`.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub previous_version: ::prost::alloc::string::String,
    /// The version that was current before executing this operation.
    /// Deprecated in favor of idempotency of the API. Use `DescribeWorkerDeployment` to get the
    /// Current version info before calling this API. By passing the `conflict_token` got from the
    /// `DescribeWorkerDeployment` call to this API you can ensure there is no interfering changes
    /// between the two calls.
    #[deprecated]
    #[prost(message, optional, tag = "3")]
    pub previous_deployment_version: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentVersion,
    >,
}
/// Set/unset the Ramping Version of a Worker Deployment and its ramp percentage.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetWorkerDeploymentRampingVersionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployment_name: ::prost::alloc::string::String,
    /// Deprecated. Use `build_id`.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The build id of the Version that you want to ramp traffic to.
    /// Pass an empty value to set the Ramping Version to nil.
    /// A nil Ramping Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
    #[prost(string, tag = "8")]
    pub build_id: ::prost::alloc::string::String,
    /// Ramp percentage to set. Valid range: \[0,100\].
    #[prost(float, tag = "4")]
    pub percentage: f32,
    /// Optional. This can be the value of conflict_token from a Describe, or another Worker
    /// Deployment API. Passing a non-nil conflict token will cause this request to fail if the
    /// Deployment's configuration has been modified between the API call that generated the
    /// token and this one.
    #[prost(bytes = "vec", tag = "5")]
    pub conflict_token: ::prost::alloc::vec::Vec<u8>,
    /// Optional. The identity of the client who initiated this request.
    #[prost(string, tag = "6")]
    pub identity: ::prost::alloc::string::String,
    /// Optional. By default this request would be rejected if not all the expected Task Queues are
    /// being polled by the new Version, to protect against accidental removal of Task Queues, or
    /// worker health issues. Pass `true` here to bypass this protection.
    /// The set of expected Task Queues equals to all the Task Queues ever polled from the existing
    /// Current Version of the Deployment, with the following exclusions:
    ///    - Task Queues that are not used anymore (inferred by having empty backlog and a task
    ///      add_rate of 0.)
    ///    - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
    ///      having a different Current Version than the Current Version of this deployment.)
    /// WARNING: Do not set this flag unless you are sure that the missing task queue poller are not
    /// needed. If the request is unexpectedly rejected due to missing pollers, then that means the
    /// pollers have not reached to the server yet. Only set this if you expect those pollers to
    /// never arrive.
    /// Note: this check only happens when the ramping version is about to change, not every time
    /// that the percentage changes. Also note that the check is against the deployment's Current
    /// Version, not the previous Ramping Version.
    #[prost(bool, tag = "7")]
    pub ignore_missing_task_queues: bool,
    /// Optional. By default this request will be rejected if no pollers have been seen for the proposed
    /// Current Version, in order to protect users from routing tasks to pollers that do not exist, leading
    /// to possible timeouts. Pass `true` here to bypass this protection.
    #[prost(bool, tag = "10")]
    pub allow_no_pollers: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetWorkerDeploymentRampingVersionResponse {
    /// This value is returned so that it can be optionally passed to APIs
    /// that write to the Worker Deployment state to ensure that the state
    /// did not change between this API call and a future write.
    #[prost(bytes = "vec", tag = "1")]
    pub conflict_token: ::prost::alloc::vec::Vec<u8>,
    /// Deprecated. Use `previous_deployment_version`.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub previous_version: ::prost::alloc::string::String,
    /// The version that was ramping before executing this operation.
    /// Deprecated in favor of idempotency of the API. Use `DescribeWorkerDeployment` to get the
    /// Ramping version info before calling this API. By passing the `conflict_token` got from the
    /// `DescribeWorkerDeployment` call to this API you can ensure there is no interfering changes
    /// between the two calls.
    #[deprecated]
    #[prost(message, optional, tag = "4")]
    pub previous_deployment_version: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentVersion,
    >,
    /// The ramping version percentage before executing this operation.
    /// Deprecated in favor of idempotency of the API. Use `DescribeWorkerDeployment` to get the
    /// Ramping version info before calling this API. By passing the `conflict_token` got from the
    /// `DescribeWorkerDeployment` call to this API you can ensure there is no interfering changes
    /// between the two calls.
    #[deprecated]
    #[prost(float, tag = "3")]
    pub previous_percentage: f32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkerDeploymentsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkerDeploymentsResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    /// The list of worker deployments.
    #[prost(message, repeated, tag = "2")]
    pub worker_deployments: ::prost::alloc::vec::Vec<
        list_worker_deployments_response::WorkerDeploymentSummary,
    >,
}
/// Nested message and enum types in `ListWorkerDeploymentsResponse`.
pub mod list_worker_deployments_response {
    /// (-- api-linter: core::0123::resource-annotation=disabled --)
    /// A subset of WorkerDeploymentInfo
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WorkerDeploymentSummary {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub create_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "3")]
        pub routing_config: ::core::option::Option<
            super::super::super::deployment::v1::RoutingConfig,
        >,
        /// Summary of the version that was added most recently in the Worker Deployment.
        #[prost(message, optional, tag = "4")]
        pub latest_version_summary: ::core::option::Option<
            super::super::super::deployment::v1::worker_deployment_info::WorkerDeploymentVersionSummary,
        >,
        /// Summary of the current version of the Worker Deployment.
        #[prost(message, optional, tag = "5")]
        pub current_version_summary: ::core::option::Option<
            super::super::super::deployment::v1::worker_deployment_info::WorkerDeploymentVersionSummary,
        >,
        /// Summary of the ramping version of the Worker Deployment.
        #[prost(message, optional, tag = "6")]
        pub ramping_version_summary: ::core::option::Option<
            super::super::super::deployment::v1::worker_deployment_info::WorkerDeploymentVersionSummary,
        >,
    }
}
/// Used for manual deletion of Versions. User can delete a Version only when all the
/// following conditions are met:
///   - It is not the Current or Ramping Version of its Deployment.
///   - It has no active pollers (none of the task queues in the Version have pollers)
///   - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
///     can be skipped by passing `skip-drainage=true`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteWorkerDeploymentVersionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Deprecated. Use `deployment_version`.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Required.
    #[prost(message, optional, tag = "5")]
    pub deployment_version: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentVersion,
    >,
    /// Pass to force deletion even if the Version is draining. In this case the open pinned
    /// workflows will be stuck until manually moved to another version by UpdateWorkflowExecutionOptions.
    #[prost(bool, tag = "3")]
    pub skip_drainage: bool,
    /// Optional. The identity of the client who initiated this request.
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteWorkerDeploymentVersionResponse {}
/// Deletes records of (an old) Deployment. A deployment can only be deleted if
/// it has no Version in it.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteWorkerDeploymentRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployment_name: ::prost::alloc::string::String,
    /// Optional. The identity of the client who initiated this request.
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteWorkerDeploymentResponse {}
/// Used to update the user-defined metadata of a Worker Deployment Version.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkerDeploymentVersionMetadataRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Deprecated. Use `deployment_version`.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Required.
    #[prost(message, optional, tag = "5")]
    pub deployment_version: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentVersion,
    >,
    #[prost(map = "string, message", tag = "3")]
    pub upsert_entries: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::common::v1::Payload,
    >,
    /// List of keys to remove from the metadata.
    #[prost(string, repeated, tag = "4")]
    pub remove_entries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The identity of the client who initiated this request.
    #[prost(string, tag = "6")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkerDeploymentVersionMetadataResponse {
    /// Full metadata after performing the update.
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::super::deployment::v1::VersionMetadata>,
}
/// Update the ManagerIdentity of a Worker Deployment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetWorkerDeploymentManagerRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployment_name: ::prost::alloc::string::String,
    /// Optional. This can be the value of conflict_token from a Describe, or another Worker
    /// Deployment API. Passing a non-nil conflict token will cause this request to fail if the
    /// Deployment's configuration has been modified between the API call that generated the
    /// token and this one.
    #[prost(bytes = "vec", tag = "5")]
    pub conflict_token: ::prost::alloc::vec::Vec<u8>,
    /// Required. The identity of the client who initiated this request.
    #[prost(string, tag = "6")]
    pub identity: ::prost::alloc::string::String,
    #[prost(
        oneof = "set_worker_deployment_manager_request::NewManagerIdentity",
        tags = "3, 4"
    )]
    pub new_manager_identity: ::core::option::Option<
        set_worker_deployment_manager_request::NewManagerIdentity,
    >,
}
/// Nested message and enum types in `SetWorkerDeploymentManagerRequest`.
pub mod set_worker_deployment_manager_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum NewManagerIdentity {
        /// Arbitrary value for `manager_identity`.
        /// Empty will unset the field.
        #[prost(string, tag = "3")]
        ManagerIdentity(::prost::alloc::string::String),
        /// True will set `manager_identity` to `identity`.
        #[prost(bool, tag = "4")]
        Self_(bool),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetWorkerDeploymentManagerResponse {
    /// This value is returned so that it can be optionally passed to APIs
    /// that write to the Worker Deployment state to ensure that the state
    /// did not change between this API call and a future write.
    #[prost(bytes = "vec", tag = "1")]
    pub conflict_token: ::prost::alloc::vec::Vec<u8>,
    /// What the `manager_identity` field was before this change.
    /// Deprecated in favor of idempotency of the API. Use `DescribeWorkerDeployment` to get the
    /// manager identity before calling this API. By passing the `conflict_token` got from the
    /// `DescribeWorkerDeployment` call to this API you can ensure there is no interfering changes
    /// between the two calls.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub previous_manager_identity: ::prost::alloc::string::String,
}
/// Returns the Current Deployment of a deployment series.
/// \[cleanup-wv-pre-release\] Pre-release deployment APIs, clean up later
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCurrentDeploymentRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub series_name: ::prost::alloc::string::String,
}
/// \[cleanup-wv-pre-release\] Pre-release deployment APIs, clean up later
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCurrentDeploymentResponse {
    #[prost(message, optional, tag = "1")]
    pub current_deployment_info: ::core::option::Option<
        super::super::deployment::v1::DeploymentInfo,
    >,
}
/// \[cleanup-wv-pre-release\] Pre-release deployment APIs, clean up later
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeploymentReachabilityRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub deployment: ::core::option::Option<super::super::deployment::v1::Deployment>,
}
/// \[cleanup-wv-pre-release\] Pre-release deployment APIs, clean up later
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeploymentReachabilityResponse {
    #[prost(message, optional, tag = "1")]
    pub deployment_info: ::core::option::Option<
        super::super::deployment::v1::DeploymentInfo,
    >,
    #[prost(enumeration = "super::super::enums::v1::DeploymentReachability", tag = "2")]
    pub reachability: i32,
    /// Reachability level might come from server cache. This timestamp specifies when the value
    /// was actually calculated.
    #[prost(message, optional, tag = "3")]
    pub last_update_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateWorkflowRuleRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The rule specification .
    #[prost(message, optional, tag = "2")]
    pub spec: ::core::option::Option<super::super::rules::v1::WorkflowRuleSpec>,
    /// If true, the rule will be applied to the currently running workflows via batch job.
    /// If not set , the rule will only be applied when triggering condition is satisfied.
    /// visibility_query in the rule will be used to select the workflows to apply the rule to.
    #[prost(bool, tag = "3")]
    pub force_scan: bool,
    /// Used to de-dupe requests. Typically should be UUID.
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    /// Identity of the actor who created the rule. Will be stored with the rule.
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
    /// Rule description.Will be stored with the rule.
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateWorkflowRuleResponse {
    /// Created rule.
    #[prost(message, optional, tag = "1")]
    pub rule: ::core::option::Option<super::super::rules::v1::WorkflowRule>,
    /// Batch Job ID if force-scan flag was provided. Otherwise empty.
    #[prost(string, tag = "2")]
    pub job_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeWorkflowRuleRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// User-specified ID of the rule to read. Unique within the namespace.
    #[prost(string, tag = "2")]
    pub rule_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeWorkflowRuleResponse {
    /// The rule that was read.
    #[prost(message, optional, tag = "1")]
    pub rule: ::core::option::Option<super::super::rules::v1::WorkflowRule>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteWorkflowRuleRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// ID of the rule to delete. Unique within the namespace.
    #[prost(string, tag = "2")]
    pub rule_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteWorkflowRuleResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkflowRulesRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkflowRulesResponse {
    #[prost(message, repeated, tag = "1")]
    pub rules: ::prost::alloc::vec::Vec<super::super::rules::v1::WorkflowRule>,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriggerWorkflowRuleRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Execution info of the workflow which scheduled this activity
    #[prost(message, optional, tag = "2")]
    pub execution: ::core::option::Option<super::super::common::v1::WorkflowExecution>,
    /// The identity of the client who initiated this request
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    /// Either provide id of existing rule, or rule specification
    #[prost(oneof = "trigger_workflow_rule_request::Rule", tags = "4, 5")]
    pub rule: ::core::option::Option<trigger_workflow_rule_request::Rule>,
}
/// Nested message and enum types in `TriggerWorkflowRuleRequest`.
pub mod trigger_workflow_rule_request {
    /// Either provide id of existing rule, or rule specification
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Rule {
        #[prost(string, tag = "4")]
        Id(::prost::alloc::string::String),
        /// Note: Rule ID and expiration date are not used in the trigger request.
        #[prost(message, tag = "5")]
        Spec(super::super::super::rules::v1::WorkflowRuleSpec),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TriggerWorkflowRuleResponse {
    /// True is the rule was applied, based on the rule conditions (predicate/visibility_query).
    #[prost(bool, tag = "1")]
    pub applied: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordWorkerHeartbeatRequest {
    /// Namespace this worker belongs to.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "2")]
    pub identity: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub worker_heartbeat: ::prost::alloc::vec::Vec<
        super::super::worker::v1::WorkerHeartbeat,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecordWorkerHeartbeatResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkersRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    /// `query` in ListWorkers is used to filter workers based on worker status info.
    /// The following worker status attributes are expected are supported as part of the query:
    /// * WorkerInstanceKey
    /// * WorkerIdentity
    /// * HostName
    /// * TaskQueue
    /// * DeploymentName
    /// * BuildId
    /// * SdkName
    /// * SdkVersion
    /// * StartTime
    /// * LastHeartbeatTime
    /// * Status
    /// Currently metrics are not supported as a part of ListWorkers query.
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkersResponse {
    #[prost(message, repeated, tag = "1")]
    pub workers_info: ::prost::alloc::vec::Vec<super::super::worker::v1::WorkerInfo>,
    /// Next page token
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTaskQueueConfigRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub identity: ::prost::alloc::string::String,
    /// Selects the task queue to update.
    #[prost(string, tag = "3")]
    pub task_queue: ::prost::alloc::string::String,
    #[prost(enumeration = "super::super::enums::v1::TaskQueueType", tag = "4")]
    pub task_queue_type: i32,
    /// Update to queue-wide rate limit.
    /// If not set, this configuration is unchanged.
    /// NOTE: A limit set by the worker is overriden; and restored again when reset.
    /// If the `rate_limit` field in the `RateLimitUpdate` is missing, remove the existing rate limit.
    #[prost(message, optional, tag = "5")]
    pub update_queue_rate_limit: ::core::option::Option<
        update_task_queue_config_request::RateLimitUpdate,
    >,
    /// Update to the default fairness key rate limit.
    /// If not set, this configuration is unchanged.
    /// If the `rate_limit` field in the `RateLimitUpdate` is missing, remove the existing rate limit.
    #[prost(message, optional, tag = "6")]
    pub update_fairness_key_rate_limit_default: ::core::option::Option<
        update_task_queue_config_request::RateLimitUpdate,
    >,
    /// If set, overrides the fairness weight for each specified fairness key.
    /// Fairness keys not listed in this map will keep their existing overrides (if any).
    #[prost(map = "string, float", tag = "7")]
    pub set_fairness_weight_overrides: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        f32,
    >,
    /// If set, removes any existing fairness weight overrides for each specified fairness key.
    /// Fairness weights for corresponding keys fall back to the values set during task creation (if any),
    /// or to the default weight of 1.0.
    #[prost(string, repeated, tag = "8")]
    pub unset_fairness_weight_overrides: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `UpdateTaskQueueConfigRequest`.
pub mod update_task_queue_config_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RateLimitUpdate {
        /// Rate Limit to be updated
        #[prost(message, optional, tag = "1")]
        pub rate_limit: ::core::option::Option<
            super::super::super::taskqueue::v1::RateLimit,
        >,
        /// Reason for why the rate limit was set.
        #[prost(string, tag = "2")]
        pub reason: ::prost::alloc::string::String,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTaskQueueConfigResponse {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<super::super::taskqueue::v1::TaskQueueConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchWorkerConfigRequest {
    /// Namespace this worker belongs to.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "2")]
    pub identity: ::prost::alloc::string::String,
    /// Reason for sending worker command, can be used for audit purpose.
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
    /// Defines which workers should receive this command.
    /// only single worker is supported at this time.
    #[prost(message, optional, tag = "6")]
    pub selector: ::core::option::Option<super::super::common::v1::WorkerSelector>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FetchWorkerConfigResponse {
    /// The worker configuration.
    #[prost(message, optional, tag = "1")]
    pub worker_config: ::core::option::Option<super::super::sdk::v1::WorkerConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkerConfigRequest {
    /// Namespace this worker belongs to.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "2")]
    pub identity: ::prost::alloc::string::String,
    /// Reason for sending worker command, can be used for audit purpose.
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
    /// Partial updates are accepted and controlled by update_mask.
    /// The worker configuration to set.
    #[prost(message, optional, tag = "4")]
    pub worker_config: ::core::option::Option<super::super::sdk::v1::WorkerConfig>,
    /// Controls which fields from `worker_config` will be applied
    #[prost(message, optional, tag = "5")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Defines which workers should receive this command.
    #[prost(message, optional, tag = "6")]
    pub selector: ::core::option::Option<super::super::common::v1::WorkerSelector>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateWorkerConfigResponse {
    #[prost(oneof = "update_worker_config_response::Response", tags = "1")]
    pub response: ::core::option::Option<update_worker_config_response::Response>,
}
/// Nested message and enum types in `UpdateWorkerConfigResponse`.
pub mod update_worker_config_response {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Response {
        /// The worker configuration. Will be returned if the command was sent to a single worker.
        #[prost(message, tag = "1")]
        WorkerConfig(super::super::super::sdk::v1::WorkerConfig),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeWorkerRequest {
    /// Namespace this worker belongs to.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Worker instance key to describe.
    #[prost(string, tag = "2")]
    pub worker_instance_key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeWorkerResponse {
    #[prost(message, optional, tag = "1")]
    pub worker_info: ::core::option::Option<super::super::worker::v1::WorkerInfo>,
}
/// Request to pause a workflow execution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseWorkflowExecutionRequest {
    /// Namespace of the workflow to pause.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// ID of the workflow execution to be paused. Required.
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    /// Run ID of the workflow execution to be paused. Optional. If not provided, the current run of the workflow will be paused.
    #[prost(string, tag = "3")]
    pub run_id: ::prost::alloc::string::String,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
    /// Reason to pause the workflow execution.
    #[prost(string, tag = "5")]
    pub reason: ::prost::alloc::string::String,
    /// A unique identifier for this pause request for idempotence. Typically UUIDv4.
    #[prost(string, tag = "6")]
    pub request_id: ::prost::alloc::string::String,
}
/// Response to a successful PauseWorkflowExecution request.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PauseWorkflowExecutionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnpauseWorkflowExecutionRequest {
    /// Namespace of the workflow to unpause.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// ID of the workflow execution to be paused. Required.
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    /// Run ID of the workflow execution to be paused. Optional. If not provided, the current run of the workflow will be paused.
    #[prost(string, tag = "3")]
    pub run_id: ::prost::alloc::string::String,
    /// The identity of the client who initiated this request.
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
    /// Reason to unpause the workflow execution.
    #[prost(string, tag = "5")]
    pub reason: ::prost::alloc::string::String,
    /// A unique identifier for this unpause request for idempotence. Typically UUIDv4.
    #[prost(string, tag = "6")]
    pub request_id: ::prost::alloc::string::String,
}
/// Response to a successful UnpauseWorkflowExecution request.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnpauseWorkflowExecutionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartActivityExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The identity of the client who initiated this request
    #[prost(string, tag = "2")]
    pub identity: ::prost::alloc::string::String,
    /// A unique identifier for this start request. Typically UUIDv4.
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    /// Identifier for this activity. Required. This identifier should be meaningful in the user's
    /// own system. It must be unique among activities in the same namespace, subject to the rules
    /// imposed by id_reuse_policy and id_conflict_policy.
    #[prost(string, tag = "4")]
    pub activity_id: ::prost::alloc::string::String,
    /// The type of the activity, a string that corresponds to a registered activity on a worker.
    #[prost(message, optional, tag = "5")]
    pub activity_type: ::core::option::Option<super::super::common::v1::ActivityType>,
    /// Task queue to schedule this activity on.
    #[prost(message, optional, tag = "6")]
    pub task_queue: ::core::option::Option<super::super::taskqueue::v1::TaskQueue>,
    /// Indicates how long the caller is willing to wait for an activity completion. Limits how long
    /// retries will be attempted. Either this or `start_to_close_timeout` must be specified.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: "to" is used to indicate interval. --)
    #[prost(message, optional, tag = "7")]
    pub schedule_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Limits time an activity task can stay in a task queue before a worker picks it up. This
    /// timeout is always non retryable, as all a retry would achieve is to put it back into the same
    /// queue. Defaults to `schedule_to_close_timeout` if not specified.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: "to" is used to indicate interval. --)
    #[prost(message, optional, tag = "8")]
    pub schedule_to_start_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Maximum time an activity is allowed to execute after being picked up by a worker. This
    /// timeout is always retryable. Either this or `schedule_to_close_timeout` must be
    /// specified.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: "to" is used to indicate interval. --)
    #[prost(message, optional, tag = "9")]
    pub start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Maximum permitted time between successful worker heartbeats.
    #[prost(message, optional, tag = "10")]
    pub heartbeat_timeout: ::core::option::Option<::prost_types::Duration>,
    /// The retry policy for the activity. Will never exceed `schedule_to_close_timeout`.
    #[prost(message, optional, tag = "11")]
    pub retry_policy: ::core::option::Option<super::super::common::v1::RetryPolicy>,
    /// Serialized arguments to the activity. These are passed as arguments to the activity function.
    #[prost(message, optional, tag = "12")]
    pub input: ::core::option::Option<super::super::common::v1::Payloads>,
    /// Defines whether to allow re-using the activity id from a previously *closed* activity.
    /// The default policy is ACTIVITY_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    #[prost(enumeration = "super::super::enums::v1::ActivityIdReusePolicy", tag = "13")]
    pub id_reuse_policy: i32,
    /// Defines how to resolve an activity id conflict with a *running* activity.
    /// The default policy is ACTIVITY_ID_CONFLICT_POLICY_FAIL.
    #[prost(
        enumeration = "super::super::enums::v1::ActivityIdConflictPolicy",
        tag = "14"
    )]
    pub id_conflict_policy: i32,
    /// Search attributes for indexing.
    #[prost(message, optional, tag = "15")]
    pub search_attributes: ::core::option::Option<
        super::super::common::v1::SearchAttributes,
    >,
    /// Header for context propagation and tracing purposes.
    #[prost(message, optional, tag = "16")]
    pub header: ::core::option::Option<super::super::common::v1::Header>,
    /// Metadata for use by user interfaces to display the fixed as-of-start summary and details of the activity.
    #[prost(message, optional, tag = "17")]
    pub user_metadata: ::core::option::Option<super::super::sdk::v1::UserMetadata>,
    /// Priority metadata.
    #[prost(message, optional, tag = "18")]
    pub priority: ::core::option::Option<super::super::common::v1::Priority>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartActivityExecutionResponse {
    /// The run ID of the activity that was started - or used (via ACTIVITY_ID_CONFLICT_POLICY_USE_EXISTING).
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
    /// If true, a new activity was started.
    #[prost(bool, tag = "2")]
    pub started: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeActivityExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub activity_id: ::prost::alloc::string::String,
    /// Activity run ID. If empty the request targets the latest run.
    #[prost(string, tag = "3")]
    pub run_id: ::prost::alloc::string::String,
    /// Include the input field in the response.
    #[prost(bool, tag = "4")]
    pub include_input: bool,
    /// Include the outcome (result/failure) in the response if the activity has completed.
    #[prost(bool, tag = "5")]
    pub include_outcome: bool,
    /// Token from a previous DescribeActivityExecutionResponse. If present, long-poll until activity
    /// state changes from the state encoded in this token. If absent, return current state immediately.
    /// If present, run_id must also be present.
    /// Note that activity state may change multiple times between requests, therefore it is not
    /// guaranteed that a client making a sequence of long-poll requests will see a complete
    /// sequence of state changes.
    #[prost(bytes = "vec", tag = "6")]
    pub long_poll_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeActivityExecutionResponse {
    /// The run ID of the activity, useful when run_id was not specified in the request.
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
    /// Information about the activity execution.
    #[prost(message, optional, tag = "2")]
    pub info: ::core::option::Option<super::super::activity::v1::ActivityExecutionInfo>,
    /// Serialized activity input, passed as arguments to the activity function.
    /// Only set if include_input was true in the request.
    #[prost(message, optional, tag = "3")]
    pub input: ::core::option::Option<super::super::common::v1::Payloads>,
    /// Only set if the activity is completed and include_outcome was true in the request.
    #[prost(message, optional, tag = "4")]
    pub outcome: ::core::option::Option<
        super::super::activity::v1::ActivityExecutionOutcome,
    >,
    /// Token for follow-on long-poll requests. Absent only if the activity is complete.
    #[prost(bytes = "vec", tag = "5")]
    pub long_poll_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollActivityExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub activity_id: ::prost::alloc::string::String,
    /// Activity run ID. If empty the request targets the latest run.
    #[prost(string, tag = "3")]
    pub run_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollActivityExecutionResponse {
    /// The run ID of the activity, useful when run_id was not specified in the request.
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub outcome: ::core::option::Option<
        super::super::activity::v1::ActivityExecutionOutcome,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListActivityExecutionsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Max number of executions to return per page.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Token returned in ListActivityExecutionsResponse.
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    /// Visibility query, see <https://docs.temporal.io/list-filter> for the syntax.
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListActivityExecutionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub executions: ::prost::alloc::vec::Vec<
        super::super::activity::v1::ActivityExecutionListInfo,
    >,
    /// Token to use to fetch the next page. If empty, there is no next page.
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountActivityExecutionsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Visibility query, see <https://docs.temporal.io/list-filter> for the syntax.
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountActivityExecutionsResponse {
    /// If `query` is not grouping by any field, the count is an approximate number
    /// of activities that match the query.
    /// If `query` is grouping by a field, the count is simply the sum of the counts
    /// of the groups returned in the response. This number can be smaller than the
    /// total number of activities matching the query.
    #[prost(int64, tag = "1")]
    pub count: i64,
    /// Contains the groups if the request is grouping by a field.
    /// The list might not be complete, and the counts of each group is approximate.
    #[prost(message, repeated, tag = "2")]
    pub groups: ::prost::alloc::vec::Vec<
        count_activity_executions_response::AggregationGroup,
    >,
}
/// Nested message and enum types in `CountActivityExecutionsResponse`.
pub mod count_activity_executions_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AggregationGroup {
        #[prost(message, repeated, tag = "1")]
        pub group_values: ::prost::alloc::vec::Vec<
            super::super::super::common::v1::Payload,
        >,
        #[prost(int64, tag = "2")]
        pub count: i64,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestCancelActivityExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub activity_id: ::prost::alloc::string::String,
    /// Activity run ID, targets the latest run if run_id is empty.
    #[prost(string, tag = "3")]
    pub run_id: ::prost::alloc::string::String,
    /// The identity of the worker/client.
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
    /// Used to de-dupe cancellation requests.
    #[prost(string, tag = "5")]
    pub request_id: ::prost::alloc::string::String,
    /// Reason for requesting the cancellation, recorded and available via the PollActivityExecution API.
    /// Not propagated to a worker if an activity attempt is currently running.
    #[prost(string, tag = "6")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestCancelActivityExecutionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminateActivityExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub activity_id: ::prost::alloc::string::String,
    /// Activity run ID, targets the latest run if run_id is empty.
    #[prost(string, tag = "3")]
    pub run_id: ::prost::alloc::string::String,
    /// The identity of the worker/client.
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
    /// Used to de-dupe termination requests.
    #[prost(string, tag = "5")]
    pub request_id: ::prost::alloc::string::String,
    /// Reason for requesting the termination, recorded in in the activity's result failure outcome.
    #[prost(string, tag = "6")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TerminateActivityExecutionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteActivityExecutionRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub activity_id: ::prost::alloc::string::String,
    /// Activity run ID, targets the latest run if run_id is empty.
    #[prost(string, tag = "3")]
    pub run_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteActivityExecutionResponse {}
/// Generated client implementations.
pub mod workflow_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// WorkflowService API defines how Temporal SDKs and other clients interact with the Temporal server
    /// to create and interact with workflows and activities.
    ///
    /// Users are expected to call `StartWorkflowExecution` to create a new workflow execution.
    ///
    /// To drive workflows, a worker using a Temporal SDK must exist which regularly polls for workflow
    /// and activity tasks from the service. For each workflow task, the sdk must process the
    /// (incremental or complete) event history and respond back with any newly generated commands.
    ///
    /// For each activity task, the worker is expected to execute the user's code which implements that
    /// activity, responding with completion or failure.
    #[derive(Debug, Clone)]
    pub struct WorkflowServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WorkflowServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WorkflowServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WorkflowServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WorkflowServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// RegisterNamespace creates a new namespace which can be used as a container for all resources.
        ///
        /// A Namespace is a top level entity within Temporal, and is used as a container for resources
        /// like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
        /// isolation for all resources within the namespace. All resources belongs to exactly one
        /// namespace.
        pub async fn register_namespace(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterNamespaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterNamespaceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RegisterNamespace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RegisterNamespace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DescribeNamespace returns the information and configuration for a registered namespace.
        pub async fn describe_namespace(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeNamespaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DescribeNamespaceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DescribeNamespace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DescribeNamespace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ListNamespaces returns the information and configuration for all namespaces.
        pub async fn list_namespaces(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNamespacesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNamespacesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListNamespaces",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListNamespaces",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// UpdateNamespace is used to update the information and configuration of a registered
        /// namespace.
        pub async fn update_namespace(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateNamespaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateNamespaceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/UpdateNamespace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "UpdateNamespace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DeprecateNamespace is used to update the state of a registered namespace to DEPRECATED.
        ///
        /// Once the namespace is deprecated it cannot be used to start new workflow executions. Existing
        /// workflow executions will continue to run on deprecated namespaces.
        /// Deprecated.
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: Deprecated --)
        pub async fn deprecate_namespace(
            &mut self,
            request: impl tonic::IntoRequest<super::DeprecateNamespaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeprecateNamespaceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DeprecateNamespace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DeprecateNamespace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// StartWorkflowExecution starts a new workflow execution.
        ///
        /// It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
        /// also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
        /// instance already exists with same workflow id.
        pub async fn start_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::StartWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/StartWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "StartWorkflowExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ExecuteMultiOperation executes multiple operations within a single workflow.
        ///
        /// Operations are started atomically, meaning if *any* operation fails to be started, none are,
        /// and the request fails. Upon start, the API returns only when *all* operations have a response.
        ///
        /// Upon failure, it returns `MultiOperationExecutionFailure` where the status code
        /// equals the status code of the *first* operation that failed to be started.
        ///
        /// NOTE: Experimental API.
        pub async fn execute_multi_operation(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteMultiOperationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteMultiOperationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ExecuteMultiOperation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ExecuteMultiOperation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
        /// `NotFound` if the specified workflow execution is unknown to the service.
        pub async fn get_workflow_execution_history(
            &mut self,
            request: impl tonic::IntoRequest<super::GetWorkflowExecutionHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetWorkflowExecutionHistoryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/GetWorkflowExecutionHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "GetWorkflowExecutionHistory",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
        /// order (starting from last event). Fails with`NotFound` if the specified workflow execution is
        /// unknown to the service.
        pub async fn get_workflow_execution_history_reverse(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetWorkflowExecutionHistoryReverseRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::GetWorkflowExecutionHistoryReverseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/GetWorkflowExecutionHistoryReverse",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "GetWorkflowExecutionHistoryReverse",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// PollWorkflowTaskQueue is called by workers to make progress on workflows.
        ///
        /// A WorkflowTask is dispatched to callers for active workflow executions with pending workflow
        /// tasks. The worker is expected to call `RespondWorkflowTaskCompleted` when it is done
        /// processing the task. The service will create a `WorkflowTaskStarted` event in the history for
        /// this task before handing it to the worker.
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        pub async fn poll_workflow_task_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::PollWorkflowTaskQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PollWorkflowTaskQueueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/PollWorkflowTaskQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "PollWorkflowTaskQueue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RespondWorkflowTaskCompleted is called by workers to successfully complete workflow tasks
        /// they received from `PollWorkflowTaskQueue`.
        ///
        /// Completing a WorkflowTask will write a `WORKFLOW_TASK_COMPLETED` event to the workflow's
        /// history, along with events corresponding to whatever commands the SDK generated while
        /// executing the task (ex timer started, activity task scheduled, etc).
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        pub async fn respond_workflow_task_completed(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondWorkflowTaskCompletedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondWorkflowTaskCompletedResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RespondWorkflowTaskCompleted",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RespondWorkflowTaskCompleted",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RespondWorkflowTaskFailed is called by workers to indicate the processing of a workflow task
        /// failed.
        ///
        /// This results in a `WORKFLOW_TASK_FAILED` event written to the history, and a new workflow
        /// task will be scheduled. This API can be used to report unhandled failures resulting from
        /// applying the workflow task.
        ///
        /// Temporal will only append first WorkflowTaskFailed event to the history of workflow execution
        /// for consecutive failures.
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        pub async fn respond_workflow_task_failed(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondWorkflowTaskFailedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondWorkflowTaskFailedResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RespondWorkflowTaskFailed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RespondWorkflowTaskFailed",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// PollActivityTaskQueue is called by workers to process activity tasks from a specific task
        /// queue.
        ///
        /// The worker is expected to call one of the `RespondActivityTaskXXX` methods when it is done
        /// processing the task.
        ///
        /// An activity task is dispatched whenever a `SCHEDULE_ACTIVITY_TASK` command is produced during
        /// workflow execution. An in memory `ACTIVITY_TASK_STARTED` event is written to mutable state
        /// before the task is dispatched to the worker. The started event, and the final event
        /// (`ACTIVITY_TASK_COMPLETED` / `ACTIVITY_TASK_FAILED` / `ACTIVITY_TASK_TIMED_OUT`) will both be
        /// written permanently to Workflow execution history when Activity is finished. This is done to
        /// avoid writing many events in the case of a failure/retry loop.
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        pub async fn poll_activity_task_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::PollActivityTaskQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PollActivityTaskQueueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/PollActivityTaskQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "PollActivityTaskQueue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
        ///
        /// If a worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
        /// then the current attempt times out. Depending on RetryPolicy, this may trigger a retry or
        /// time out the activity.
        ///
        /// For workflow activities, an `ACTIVITY_TASK_TIMED_OUT` event will be written to the workflow
        /// history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in such situations,
        /// in that event, the SDK should request cancellation of the activity.
        ///
        /// The request may contain response `details` which will be persisted by the server and may be
        /// used by the activity to checkpoint progress. The `cancel_requested` field in the response
        /// indicates whether cancellation has been requested for the activity.
        pub async fn record_activity_task_heartbeat(
            &mut self,
            request: impl tonic::IntoRequest<super::RecordActivityTaskHeartbeatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RecordActivityTaskHeartbeatResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RecordActivityTaskHeartbeat",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
        /// namespace/workflow id/activity id instead of task token.
        ///
        /// (-- api-linter: core::0136::prepositions=disabled
        ///     aip.dev/not-precedent: "By" is used to indicate request type. --)
        pub async fn record_activity_task_heartbeat_by_id(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RecordActivityTaskHeartbeatByIdRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RecordActivityTaskHeartbeatByIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeatById",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RecordActivityTaskHeartbeatById",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RespondActivityTaskCompleted is called by workers when they successfully complete an activity
        /// task.
        ///
        /// For workflow activities, this results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
        /// and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
        /// no longer valid due to activity timeout, already being completed, or never having existed.
        pub async fn respond_activity_task_completed(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondActivityTaskCompletedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondActivityTaskCompletedResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompleted",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RespondActivityTaskCompleted",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// See `RespondActivityTaskCompleted`. This version allows clients to record completions by
        /// namespace/workflow id/activity id instead of task token.
        ///
        /// (-- api-linter: core::0136::prepositions=disabled
        ///     aip.dev/not-precedent: "By" is used to indicate request type. --)
        pub async fn respond_activity_task_completed_by_id(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RespondActivityTaskCompletedByIdRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RespondActivityTaskCompletedByIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompletedById",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RespondActivityTaskCompletedById",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RespondActivityTaskFailed is called by workers when processing an activity task fails.
        ///
        /// This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
        /// a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
        /// longer valid due to activity timeout, already being completed, or never having existed.
        pub async fn respond_activity_task_failed(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondActivityTaskFailedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondActivityTaskFailedResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RespondActivityTaskFailed",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// See `RecordActivityTaskFailed`. This version allows clients to record failures by
        /// namespace/workflow id/activity id instead of task token.
        ///
        /// (-- api-linter: core::0136::prepositions=disabled
        ///     aip.dev/not-precedent: "By" is used to indicate request type. --)
        pub async fn respond_activity_task_failed_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondActivityTaskFailedByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondActivityTaskFailedByIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailedById",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RespondActivityTaskFailedById",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RespondActivityTaskFailed is called by workers when processing an activity task fails.
        ///
        /// For workflow activities, this results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
        /// and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
        /// no longer valid due to activity timeout, already being completed, or never having existed.
        pub async fn respond_activity_task_canceled(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondActivityTaskCanceledRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondActivityTaskCanceledResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceled",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RespondActivityTaskCanceled",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// See `RespondActivityTaskCanceled`. This version allows clients to record failures by
        /// namespace/workflow id/activity id instead of task token.
        ///
        /// (-- api-linter: core::0136::prepositions=disabled
        ///     aip.dev/not-precedent: "By" is used to indicate request type. --)
        pub async fn respond_activity_task_canceled_by_id(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RespondActivityTaskCanceledByIdRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RespondActivityTaskCanceledByIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceledById",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RespondActivityTaskCanceledById",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
        /// a workflow execution.
        ///
        /// This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
        /// workflow history and a new workflow task created for the workflow. It returns success if the requested
        /// workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
        pub async fn request_cancel_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RequestCancelWorkflowExecutionRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RequestCancelWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RequestCancelWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RequestCancelWorkflowExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// SignalWorkflowExecution is used to send a signal to a running workflow execution.
        ///
        /// This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
        /// task being created for the execution.
        pub async fn signal_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::SignalWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SignalWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/SignalWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "SignalWorkflowExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
        /// it isn't yet started.
        ///
        /// If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
        /// and a workflow task is generated.
        ///
        /// If the workflow is not running or not found, then the workflow is created with
        /// `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
        /// workflow task is generated.
        ///
        /// (-- api-linter: core::0136::prepositions=disabled
        ///     aip.dev/not-precedent: "With" is used to indicate combined operation. --)
        pub async fn signal_with_start_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SignalWithStartWorkflowExecutionRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SignalWithStartWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/SignalWithStartWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "SignalWithStartWorkflowExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ResetWorkflowExecution will reset an existing workflow execution to a specified
        /// `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
        /// execution instance. "Exclusive" means the identified completed event itself is not replayed
        /// in the reset history; the preceding `WORKFLOW_TASK_STARTED` event remains and will be marked as failed
        /// immediately, and a new workflow task will be scheduled to retry it.
        pub async fn reset_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::ResetWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ResetWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ResetWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ResetWorkflowExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// TerminateWorkflowExecution terminates an existing workflow execution by recording a
        /// `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
        /// execution instance.
        pub async fn terminate_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::TerminateWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TerminateWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/TerminateWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "TerminateWorkflowExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DeleteWorkflowExecution asynchronously deletes a specific Workflow Execution (when
        /// WorkflowExecution.run_id is provided) or the latest Workflow Execution (when
        /// WorkflowExecution.run_id is not provided). If the Workflow Execution is Running, it will be
        /// terminated before deletion.
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: Workflow deletion not exposed to HTTP, users should use cancel or terminate. --)
        pub async fn delete_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DeleteWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DeleteWorkflowExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific namespace.
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
        pub async fn list_open_workflow_executions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOpenWorkflowExecutionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOpenWorkflowExecutionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListOpenWorkflowExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListOpenWorkflowExecutions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific namespace.
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
        pub async fn list_closed_workflow_executions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListClosedWorkflowExecutionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListClosedWorkflowExecutionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListClosedWorkflowExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListClosedWorkflowExecutions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.
        pub async fn list_workflow_executions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListWorkflowExecutionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListWorkflowExecutionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListWorkflowExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListWorkflowExecutions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.
        pub async fn list_archived_workflow_executions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListArchivedWorkflowExecutionsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListArchivedWorkflowExecutionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListArchivedWorkflowExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListArchivedWorkflowExecutions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ScanWorkflowExecutions _was_ a visibility API to list large amount of workflow executions in a specific namespace without order.
        /// It has since been deprecated in favor of `ListWorkflowExecutions` and rewritten to use `ListWorkflowExecutions` internally.
        ///
        /// Deprecated: Replaced with `ListWorkflowExecutions`.
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
        pub async fn scan_workflow_executions(
            &mut self,
            request: impl tonic::IntoRequest<super::ScanWorkflowExecutionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ScanWorkflowExecutionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ScanWorkflowExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ScanWorkflowExecutions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.
        pub async fn count_workflow_executions(
            &mut self,
            request: impl tonic::IntoRequest<super::CountWorkflowExecutionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CountWorkflowExecutionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/CountWorkflowExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "CountWorkflowExecutions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do not expose this search attribute API to HTTP (but may expose on OperatorService). --)
        pub async fn get_search_attributes(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSearchAttributesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSearchAttributesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/GetSearchAttributes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "GetSearchAttributes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RespondQueryTaskCompleted is called by workers to complete queries which were delivered on
        /// the `query` (not `queries`) field of a `PollWorkflowTaskQueueResponse`.
        ///
        /// Completing the query will unblock the corresponding client call to `QueryWorkflow` and return
        /// the query result a response.
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        pub async fn respond_query_task_completed(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondQueryTaskCompletedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondQueryTaskCompletedResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RespondQueryTaskCompleted",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RespondQueryTaskCompleted",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ResetStickyTaskQueue resets the sticky task queue related information in the mutable state of
        /// a given workflow. This is prudent for workers to perform if a workflow has been paged out of
        /// their cache.
        ///
        /// Things cleared are:
        /// 1. StickyTaskQueue
        /// 2. StickyScheduleToStartTimeout
        ///
        /// When possible, ShutdownWorker should be preferred over
        /// ResetStickyTaskQueue (particularly when a worker is shutting down or
        /// cycling).
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        pub async fn reset_sticky_task_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::ResetStickyTaskQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ResetStickyTaskQueueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ResetStickyTaskQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ResetStickyTaskQueue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ShutdownWorker is used to indicate that the given sticky task
        /// queue is no longer being polled by its worker. Following the completion of
        /// ShutdownWorker, newly-added workflow tasks will instead be placed
        /// in the normal task queue, eligible for any worker to pick up.
        ///
        /// ShutdownWorker should be called by workers while shutting down,
        /// after they've shut down their pollers. If another sticky poll
        /// request is issued, the sticky task queue will be revived.
        ///
        /// As of Temporal Server v1.25.0, ShutdownWorker hasn't yet been implemented.
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        pub async fn shutdown_worker(
            &mut self,
            request: impl tonic::IntoRequest<super::ShutdownWorkerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ShutdownWorkerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ShutdownWorker",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ShutdownWorker",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryWorkflow requests a query be executed for a specified workflow execution.
        pub async fn query_workflow(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryWorkflowRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryWorkflowResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/QueryWorkflow",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "QueryWorkflow",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DescribeWorkflowExecution returns information about the specified workflow execution.
        pub async fn describe_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DescribeWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DescribeWorkflowExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:
        ///   - List of pollers
        ///   - Workflow Reachability status
        ///   - Backlog info for Workflow and/or Activity tasks
        pub async fn describe_task_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeTaskQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DescribeTaskQueueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DescribeTaskQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DescribeTaskQueue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetClusterInfo returns information about temporal cluster
        pub async fn get_cluster_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetClusterInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetClusterInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/GetClusterInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "GetClusterInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetSystemInfo returns information about the system.
        pub async fn get_system_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSystemInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSystemInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/GetSystemInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "GetSystemInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do not expose this low-level API to HTTP. --)
        pub async fn list_task_queue_partitions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTaskQueuePartitionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTaskQueuePartitionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListTaskQueuePartitions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListTaskQueuePartitions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new schedule.
        pub async fn create_schedule(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateScheduleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateScheduleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/CreateSchedule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "CreateSchedule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the schedule description and current state of an existing schedule.
        pub async fn describe_schedule(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeScheduleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DescribeScheduleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DescribeSchedule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DescribeSchedule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the configuration or state of an existing schedule.
        pub async fn update_schedule(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateScheduleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateScheduleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/UpdateSchedule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "UpdateSchedule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Makes a specific change to a schedule or triggers an immediate action.
        pub async fn patch_schedule(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchScheduleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PatchScheduleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/PatchSchedule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "PatchSchedule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists matching times within a range.
        pub async fn list_schedule_matching_times(
            &mut self,
            request: impl tonic::IntoRequest<super::ListScheduleMatchingTimesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListScheduleMatchingTimesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListScheduleMatchingTimes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListScheduleMatchingTimes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a schedule, removing it from the system.
        pub async fn delete_schedule(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteScheduleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteScheduleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DeleteSchedule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DeleteSchedule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all schedules in a namespace.
        pub async fn list_schedules(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSchedulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSchedulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListSchedules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListSchedules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// CountSchedules is a visibility API to count schedules in a specific namespace.
        pub async fn count_schedules(
            &mut self,
            request: impl tonic::IntoRequest<super::CountSchedulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CountSchedulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/CountSchedules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "CountSchedules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deprecated. Use `UpdateWorkerVersioningRules`.
        ///
        /// Allows users to specify sets of worker build id versions on a per task queue basis. Versions
        /// are ordered, and may be either compatible with some extant version, or a new incompatible
        /// version, forming sets of ids which are incompatible with each other, but whose contained
        /// members are compatible with one another.
        ///
        /// A single build id may be mapped to multiple task queues using this API for cases where a single process hosts
        /// multiple workers.
        ///
        /// To query which workers can be retired, use the `GetWorkerTaskReachability` API.
        ///
        /// NOTE: The number of task queues mapped to a single build id is limited by the `limit.taskQueuesPerBuildId`
        /// (default is 20), if this limit is exceeded this API will error with a FailedPrecondition.
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do yet expose versioning API to HTTP. --)
        pub async fn update_worker_build_id_compatibility(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateWorkerBuildIdCompatibilityRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::UpdateWorkerBuildIdCompatibilityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkerBuildIdCompatibility",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "UpdateWorkerBuildIdCompatibility",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deprecated. Use `GetWorkerVersioningRules`.
        /// Fetches the worker build id versioning sets for a task queue.
        pub async fn get_worker_build_id_compatibility(
            &mut self,
            request: impl tonic::IntoRequest<super::GetWorkerBuildIdCompatibilityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetWorkerBuildIdCompatibilityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/GetWorkerBuildIdCompatibility",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "GetWorkerBuildIdCompatibility",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Use this API to manage Worker Versioning Rules for a given Task Queue. There are two types of
        /// rules: Build ID Assignment rules and Compatible Build ID Redirect rules.
        ///
        /// Assignment rules determine how to assign new executions to a Build IDs. Their primary
        /// use case is to specify the latest Build ID but they have powerful features for gradual rollout
        /// of a new Build ID.
        ///
        /// Once a workflow execution is assigned to a Build ID and it completes its first Workflow Task,
        /// the workflow stays on the assigned Build ID regardless of changes in assignment rules. This
        /// eliminates the need for compatibility between versions when you only care about using the new
        /// version for new workflows and let existing workflows finish in their own version.
        ///
        /// Activities, Child Workflows and Continue-as-New executions have the option to inherit the
        /// Build ID of their parent/previous workflow or use the latest assignment rules to independently
        /// select a Build ID.
        ///
        /// Redirect rules should only be used when you want to move workflows and activities assigned to
        /// one Build ID (source) to another compatible Build ID (target). You are responsible to make sure
        /// the target Build ID of a redirect rule is able to process event histories made by the source
        /// Build ID by using [Patching](https://docs.temporal.io/workflows#patching) or other means.
        ///
        /// WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do yet expose versioning API to HTTP. --)
        pub async fn update_worker_versioning_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateWorkerVersioningRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateWorkerVersioningRulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkerVersioningRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "UpdateWorkerVersioningRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Fetches the Build ID assignment and redirect rules for a Task Queue.
        /// WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
        pub async fn get_worker_versioning_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::GetWorkerVersioningRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetWorkerVersioningRulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/GetWorkerVersioningRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "GetWorkerVersioningRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deprecated. Use `DescribeTaskQueue`.
        ///
        /// Fetches task reachability to determine whether a worker may be retired.
        /// The request may specify task queues to query for or let the server fetch all task queues mapped to the given
        /// build IDs.
        ///
        /// When requesting a large number of task queues or all task queues associated with the given build ids in a
        /// namespace, all task queues will be listed in the response but some of them may not contain reachability
        /// information due to a server enforced limit. When reaching the limit, task queues that reachability information
        /// could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
        /// another call to get the reachability for those task queues.
        ///
        /// Open source users can adjust this limit by setting the server's dynamic config value for
        /// `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
        pub async fn get_worker_task_reachability(
            &mut self,
            request: impl tonic::IntoRequest<super::GetWorkerTaskReachabilityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetWorkerTaskReachabilityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/GetWorkerTaskReachability",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "GetWorkerTaskReachability",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Describes a worker deployment.
        /// Experimental. This API might significantly change or be removed in a future release.
        /// Deprecated. Replaced with `DescribeWorkerDeploymentVersion`.
        pub async fn describe_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DescribeDeploymentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DescribeDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DescribeDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Describes a worker deployment version.
        /// Experimental. This API might significantly change or be removed in a future release.
        pub async fn describe_worker_deployment_version(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DescribeWorkerDeploymentVersionRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::DescribeWorkerDeploymentVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorkerDeploymentVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DescribeWorkerDeploymentVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists worker deployments in the namespace. Optionally can filter based on deployment series
        /// name.
        /// Experimental. This API might significantly change or be removed in a future release.
        /// Deprecated. Replaced with `ListWorkerDeployments`.
        pub async fn list_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListDeployments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the reachability level of a worker deployment to help users decide when it is time
        /// to decommission a deployment. Reachability level is calculated based on the deployment's
        /// `status` and existing workflows that depend on the given deployment for their execution.
        /// Calculating reachability is relatively expensive. Therefore, server might return a recently
        /// cached value. In such a case, the `last_update_time` will inform you about the actual
        /// reachability calculation time.
        /// Experimental. This API might significantly change or be removed in a future release.
        /// Deprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`.
        pub async fn get_deployment_reachability(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDeploymentReachabilityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetDeploymentReachabilityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/GetDeploymentReachability",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "GetDeploymentReachability",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the current deployment (and its info) for a given deployment series.
        /// Experimental. This API might significantly change or be removed in a future release.
        /// Deprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`.
        pub async fn get_current_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCurrentDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCurrentDeploymentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/GetCurrentDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "GetCurrentDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets a deployment as the current deployment for its deployment series. Can optionally update
        /// the metadata of the deployment as well.
        /// Experimental. This API might significantly change or be removed in a future release.
        /// Deprecated. Replaced by `SetWorkerDeploymentCurrentVersion`.
        pub async fn set_current_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::SetCurrentDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetCurrentDeploymentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/SetCurrentDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "SetCurrentDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping
        /// Version if it is the Version being set as Current.
        /// Experimental. This API might significantly change or be removed in a future release.
        pub async fn set_worker_deployment_current_version(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetWorkerDeploymentCurrentVersionRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SetWorkerDeploymentCurrentVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/SetWorkerDeploymentCurrentVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "SetWorkerDeploymentCurrentVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Describes a Worker Deployment.
        /// Experimental. This API might significantly change or be removed in a future release.
        pub async fn describe_worker_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeWorkerDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DescribeWorkerDeploymentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorkerDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DescribeWorkerDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes records of (an old) Deployment. A deployment can only be deleted if
        /// it has no Version in it.
        /// Experimental. This API might significantly change or be removed in a future release.
        pub async fn delete_worker_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteWorkerDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteWorkerDeploymentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DeleteWorkerDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DeleteWorkerDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Used for manual deletion of Versions. User can delete a Version only when all the
        /// following conditions are met:
        ///  - It is not the Current or Ramping Version of its Deployment.
        ///  - It has no active pollers (none of the task queues in the Version have pollers)
        ///  - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
        ///    can be skipped by passing `skip-drainage=true`.
        /// Experimental. This API might significantly change or be removed in a future release.
        pub async fn delete_worker_deployment_version(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteWorkerDeploymentVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteWorkerDeploymentVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DeleteWorkerDeploymentVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DeleteWorkerDeploymentVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for
        /// gradual ramp to unversioned workers too.
        /// Experimental. This API might significantly change or be removed in a future release.
        pub async fn set_worker_deployment_ramping_version(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetWorkerDeploymentRampingVersionRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SetWorkerDeploymentRampingVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/SetWorkerDeploymentRampingVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "SetWorkerDeploymentRampingVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all Worker Deployments that are tracked in the Namespace.
        /// Experimental. This API might significantly change or be removed in a future release.
        pub async fn list_worker_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListWorkerDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListWorkerDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListWorkerDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListWorkerDeployments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the user-given metadata attached to a Worker Deployment Version.
        /// Experimental. This API might significantly change or be removed in a future release.
        pub async fn update_worker_deployment_version_metadata(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateWorkerDeploymentVersionMetadataRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::UpdateWorkerDeploymentVersionMetadataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkerDeploymentVersionMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "UpdateWorkerDeploymentVersionMetadata",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set/unset the ManagerIdentity of a Worker Deployment.
        /// Experimental. This API might significantly change or be removed in a future release.
        pub async fn set_worker_deployment_manager(
            &mut self,
            request: impl tonic::IntoRequest<super::SetWorkerDeploymentManagerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetWorkerDeploymentManagerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/SetWorkerDeploymentManager",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "SetWorkerDeploymentManager",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Invokes the specified Update function on user Workflow code.
        pub async fn update_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "UpdateWorkflowExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Polls a Workflow Execution for the outcome of a Workflow Update
        /// previously issued through the UpdateWorkflowExecution RPC. The effective
        /// timeout on this call will be shorter of the the caller-supplied gRPC
        /// timeout and the server's configured long-poll timeout.
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We don't expose update polling API to HTTP in favor of a potential future non-blocking form. --)
        pub async fn poll_workflow_execution_update(
            &mut self,
            request: impl tonic::IntoRequest<super::PollWorkflowExecutionUpdateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PollWorkflowExecutionUpdateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/PollWorkflowExecutionUpdate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "PollWorkflowExecutionUpdate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// StartBatchOperation starts a new batch operation
        pub async fn start_batch_operation(
            &mut self,
            request: impl tonic::IntoRequest<super::StartBatchOperationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartBatchOperationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/StartBatchOperation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "StartBatchOperation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// StopBatchOperation stops a batch operation
        pub async fn stop_batch_operation(
            &mut self,
            request: impl tonic::IntoRequest<super::StopBatchOperationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StopBatchOperationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/StopBatchOperation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "StopBatchOperation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DescribeBatchOperation returns the information about a batch operation
        pub async fn describe_batch_operation(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeBatchOperationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DescribeBatchOperationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DescribeBatchOperation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DescribeBatchOperation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ListBatchOperations returns a list of batch operations
        pub async fn list_batch_operations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBatchOperationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBatchOperationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListBatchOperations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListBatchOperations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// PollNexusTaskQueue is a long poll call used by workers to receive Nexus tasks.
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        pub async fn poll_nexus_task_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::PollNexusTaskQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PollNexusTaskQueueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/PollNexusTaskQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "PollNexusTaskQueue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RespondNexusTaskCompleted is called by workers to respond to Nexus tasks received via PollNexusTaskQueue.
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        pub async fn respond_nexus_task_completed(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondNexusTaskCompletedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondNexusTaskCompletedResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RespondNexusTaskCompleted",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RespondNexusTaskCompleted",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RespondNexusTaskFailed is called by workers to fail Nexus tasks received via PollNexusTaskQueue.
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        pub async fn respond_nexus_task_failed(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondNexusTaskFailedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondNexusTaskFailedResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RespondNexusTaskFailed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RespondNexusTaskFailed",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.
        /// If there are multiple pending activities of the provided type - all of them will be updated.
        /// This API will be deprecated soon and replaced with a newer UpdateActivityExecutionOptions that is better named and
        /// structured to work well for standalone activities.
        pub async fn update_activity_options(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateActivityOptionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateActivityOptionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/UpdateActivityOptions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "UpdateActivityOptions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution.
        pub async fn update_workflow_execution_options(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateWorkflowExecutionOptionsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::UpdateWorkflowExecutionOptionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkflowExecutionOptions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "UpdateWorkflowExecutionOptions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// PauseActivity pauses the execution of an activity specified by its ID or type.
        /// If there are multiple pending activities of the provided type - all of them will be paused
        ///
        /// Pausing an activity means:
        /// - If the activity is currently waiting for a retry or is running and subsequently fails,
        ///   it will not be rescheduled until it is unpaused.
        /// - If the activity is already paused, calling this method will have no effect.
        /// - If the activity is running and finishes successfully, the activity will be completed.
        /// - If the activity is running and finishes with failure:
        ///   * if there is no retry left - the activity will be completed.
        ///   * if there are more retries left - the activity will be paused.
        /// For long-running activities:
        /// - activities in paused state will send a cancellation with "activity_paused" set to 'true' in response to 'RecordActivityTaskHeartbeat'.
        /// - The activity should respond to the cancellation accordingly.
        ///
        /// Returns a `NotFound` error if there is no pending activity with the provided ID or type
        /// This API will be deprecated soon and replaced with a newer PauseActivityExecution that is better named and
        /// structured to work well for standalone activities.
        pub async fn pause_activity(
            &mut self,
            request: impl tonic::IntoRequest<super::PauseActivityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PauseActivityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/PauseActivity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "PauseActivity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// UnpauseActivity unpauses the execution of an activity specified by its ID or type.
        /// If there are multiple pending activities of the provided type - all of them will be unpaused.
        ///
        /// If activity is not paused, this call will have no effect.
        /// If the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).
        /// Once the activity is unpaused, all timeout timers will be regenerated.
        ///
        /// Flags:
        /// 'jitter': the activity will be scheduled at a random time within the jitter duration.
        /// 'reset_attempts': the number of attempts will be reset.
        /// 'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.
        ///
        /// Returns a `NotFound` error if there is no pending activity with the provided ID or type
        /// This API will be deprecated soon and replaced with a newer UnpauseActivityExecution that is better named and
        /// structured to work well for standalone activities.
        pub async fn unpause_activity(
            &mut self,
            request: impl tonic::IntoRequest<super::UnpauseActivityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnpauseActivityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/UnpauseActivity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "UnpauseActivity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ResetActivity resets the execution of an activity specified by its ID or type.
        /// If there are multiple pending activities of the provided type - all of them will be reset.
        ///
        /// Resetting an activity means:
        /// * number of attempts will be reset to 0.
        /// * activity timeouts will be reset.
        /// * if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:
        ///    it will be scheduled immediately (* see 'jitter' flag),
        ///
        /// Flags:
        ///
        /// 'jitter': the activity will be scheduled at a random time within the jitter duration.
        /// If the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.
        /// 'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.
        /// 'keep_paused': if the activity is paused, it will remain paused.
        ///
        /// Returns a `NotFound` error if there is no pending activity with the provided ID or type.
        /// This API will be deprecated soon and replaced with a newer ResetActivityExecution that is better named and
        /// structured to work well for standalone activities.
        pub async fn reset_activity(
            &mut self,
            request: impl tonic::IntoRequest<super::ResetActivityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ResetActivityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ResetActivity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ResetActivity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a new workflow rule. The rules are used to control the workflow execution.
        /// The rule will be applied to all running and new workflows in the namespace.
        /// If the rule with such ID already exist this call will fail
        /// Note: the rules are part of namespace configuration and will be stored in the namespace config.
        /// Namespace config is eventually consistent.
        pub async fn create_workflow_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateWorkflowRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateWorkflowRuleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/CreateWorkflowRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "CreateWorkflowRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DescribeWorkflowRule return the rule specification for existing rule id.
        /// If there is no rule with such id - NOT FOUND error will be returned.
        pub async fn describe_workflow_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeWorkflowRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DescribeWorkflowRuleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorkflowRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DescribeWorkflowRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete rule by rule id
        pub async fn delete_workflow_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteWorkflowRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteWorkflowRuleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DeleteWorkflowRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DeleteWorkflowRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Return all namespace workflow rules
        pub async fn list_workflow_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::ListWorkflowRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListWorkflowRulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListWorkflowRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListWorkflowRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// TriggerWorkflowRule allows to:
        ///  * trigger existing rule for a specific workflow execution;
        ///  * trigger rule for a specific workflow execution without creating a rule;
        /// This is useful for one-off operations.
        pub async fn trigger_workflow_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::TriggerWorkflowRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TriggerWorkflowRuleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/TriggerWorkflowRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "TriggerWorkflowRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// WorkerHeartbeat receive heartbeat request from the worker.
        pub async fn record_worker_heartbeat(
            &mut self,
            request: impl tonic::IntoRequest<super::RecordWorkerHeartbeatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RecordWorkerHeartbeatResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RecordWorkerHeartbeat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RecordWorkerHeartbeat",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ListWorkers is a visibility API to list worker status information in a specific namespace.
        pub async fn list_workers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListWorkersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListWorkersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListWorkers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListWorkers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates task queue configuration.
        /// For the overall queue rate limit: the rate limit set by this api overrides the worker-set rate limit,
        /// which uncouples the rate limit from the worker lifecycle.
        /// If the overall queue rate limit is unset, the worker-set rate limit takes effect.
        pub async fn update_task_queue_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTaskQueueConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateTaskQueueConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/UpdateTaskQueueConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "UpdateTaskQueueConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// FetchWorkerConfig returns the worker configuration for a specific worker.
        pub async fn fetch_worker_config(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchWorkerConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchWorkerConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/FetchWorkerConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "FetchWorkerConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// UpdateWorkerConfig updates the worker configuration of one or more workers.
        /// Can be used to partially update the worker configuration.
        /// Can be used to update the configuration of multiple workers.
        pub async fn update_worker_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateWorkerConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateWorkerConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/UpdateWorkerConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "UpdateWorkerConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DescribeWorker returns information about the specified worker.
        pub async fn describe_worker(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeWorkerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DescribeWorkerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorker",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DescribeWorker",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Note: This is an experimental API and the behavior may change in a future release.
        /// PauseWorkflowExecution pauses the workflow execution specified in the request. Pausing a workflow execution results in
        /// - The workflow execution status changes to `PAUSED` and a new WORKFLOW_EXECUTION_PAUSED event is added to the history
        /// - No new workflow tasks or activity tasks are dispatched.
        ///   - Any workflow task currently executing on the worker will be allowed to complete.
        ///   - Any activity task currently executing will be paused.
        /// - All server-side events will continue to be processed by the server.
        /// - Queries & Updates on a paused workflow will be rejected.
        pub async fn pause_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::PauseWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PauseWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/PauseWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "PauseWorkflowExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Note: This is an experimental API and the behavior may change in a future release.
        /// UnpauseWorkflowExecution unpauses a previously paused workflow execution specified in the request.
        /// Unpausing a workflow execution results in
        /// - The workflow execution status changes to `RUNNING` and a new WORKFLOW_EXECUTION_UNPAUSED event is added to the history
        /// - Workflow tasks and activity tasks are resumed.
        pub async fn unpause_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::UnpauseWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnpauseWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/UnpauseWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "UnpauseWorkflowExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// StartActivityExecution starts a new activity execution.
        ///
        /// Returns an `ActivityExecutionAlreadyStarted` error if an instance already exists with same activity ID in this namespace
        /// unless permitted by the specified ID conflict policy.
        pub async fn start_activity_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::StartActivityExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartActivityExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/StartActivityExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "StartActivityExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DescribeActivityExecution returns information about an activity execution.
        /// It can be used to:
        /// - Get current activity info without waiting
        /// - Long-poll for next state change and return new activity info
        /// Response can optionally include activity input or outcome (if the activity has completed).
        pub async fn describe_activity_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeActivityExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DescribeActivityExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DescribeActivityExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DescribeActivityExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// PollActivityExecution long-polls for an activity execution to complete and returns the
        /// outcome (result or failure).
        pub async fn poll_activity_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::PollActivityExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PollActivityExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/PollActivityExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "PollActivityExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ListActivityExecutions is a visibility API to list activity executions in a specific namespace.
        pub async fn list_activity_executions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListActivityExecutionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListActivityExecutionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/ListActivityExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "ListActivityExecutions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// CountActivityExecutions is a visibility API to count activity executions in a specific namespace.
        pub async fn count_activity_executions(
            &mut self,
            request: impl tonic::IntoRequest<super::CountActivityExecutionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CountActivityExecutionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/CountActivityExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "CountActivityExecutions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RequestCancelActivityExecution requests cancellation of an activity execution.
        ///
        /// Cancellation is cooperative: this call records the request, but the activity must detect and
        /// acknowledge it for the activity to reach CANCELED status. The cancellation signal is
        /// delivered via `cancel_requested` in the heartbeat response; SDKs surface this via
        /// language-idiomatic mechanisms (context cancellation, exceptions, abort signals).
        pub async fn request_cancel_activity_execution(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RequestCancelActivityExecutionRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RequestCancelActivityExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/RequestCancelActivityExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "RequestCancelActivityExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// TerminateActivityExecution terminates an existing activity execution immediately.
        ///
        /// Termination does not reach the worker and the activity code cannot react to it. A terminated activity may have a
        /// running attempt.
        pub async fn terminate_activity_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::TerminateActivityExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TerminateActivityExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/TerminateActivityExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "TerminateActivityExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DeleteActivityExecution asynchronously deletes a specific activity execution (when
        /// ActivityExecution.run_id is provided) or the latest activity execution (when
        /// ActivityExecution.run_id is not provided). If the activity Execution is running, it will be
        /// terminated before deletion.
        ///
        /// (-- api-linter: core::0127::http-annotation=disabled
        ///     aip.dev/not-precedent: Activity deletion not exposed to HTTP, users should use cancel or terminate. --)
        pub async fn delete_activity_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteActivityExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteActivityExecutionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/temporal.api.workflowservice.v1.WorkflowService/DeleteActivityExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "temporal.api.workflowservice.v1.WorkflowService",
                        "DeleteActivityExecution",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
