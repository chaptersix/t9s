// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleActivityTaskCommandAttributes {
    #[prost(string, tag = "1")]
    pub activity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub activity_type: ::core::option::Option<super::super::common::v1::ActivityType>,
    #[prost(message, optional, tag = "4")]
    pub task_queue: ::core::option::Option<super::super::taskqueue::v1::TaskQueue>,
    #[prost(message, optional, tag = "5")]
    pub header: ::core::option::Option<super::super::common::v1::Header>,
    #[prost(message, optional, tag = "6")]
    pub input: ::core::option::Option<super::super::common::v1::Payloads>,
    /// Indicates how long the caller is willing to wait for activity completion. The "schedule" time
    /// is when the activity is initially scheduled, not when the most recent retry is scheduled.
    /// Limits how long retries will be attempted. Either this or `start_to_close_timeout` must be
    /// specified. When not specified, defaults to the workflow execution timeout.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: "to" is used to indicate interval. --)
    #[prost(message, optional, tag = "7")]
    pub schedule_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Limits the time an activity task can stay in a task queue before a worker picks it up. The
    /// "schedule" time is when the most recent retry is scheduled. This timeout should usually not
    /// be set: it's useful in specific scenarios like worker-specific task queues. This timeout is
    /// always non retryable, as all a retry would achieve is to put it back into the same queue.
    /// Defaults to `schedule_to_close_timeout` or workflow execution timeout if that is not
    /// specified. More info:
    /// <https://docs.temporal.io/docs/content/what-is-a-schedule-to-start-timeout/>
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: "to" is used to indicate interval. --)
    #[prost(message, optional, tag = "8")]
    pub schedule_to_start_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Maximum time an activity is allowed to execute after being picked up by a worker. This
    /// timeout is always retryable. Either this or `schedule_to_close_timeout` must be specified.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: "to" is used to indicate interval. --)
    #[prost(message, optional, tag = "9")]
    pub start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Maximum permitted time between successful worker heartbeats.
    #[prost(message, optional, tag = "10")]
    pub heartbeat_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Activities are provided by a default retry policy which is controlled through the service's
    /// dynamic configuration. Retries will be attempted until `schedule_to_close_timeout` has
    /// elapsed. To disable retries set retry_policy.maximum_attempts to 1.
    #[prost(message, optional, tag = "11")]
    pub retry_policy: ::core::option::Option<super::super::common::v1::RetryPolicy>,
    /// Request to start the activity directly bypassing matching service and worker polling
    /// The slot for executing the activity should be reserved when setting this field to true.
    #[prost(bool, tag = "12")]
    pub request_eager_execution: bool,
    /// If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,
    /// Assignment rules of the activity's Task Queue will be used to determine the Build ID.
    #[prost(bool, tag = "13")]
    pub use_workflow_build_id: bool,
    /// Priority metadata. If this message is not present, or any fields are not
    /// present, they inherit the values from the workflow.
    #[prost(message, optional, tag = "14")]
    pub priority: ::core::option::Option<super::super::common::v1::Priority>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestCancelActivityTaskCommandAttributes {
    /// The `ACTIVITY_TASK_SCHEDULED` event id for the activity being cancelled.
    #[prost(int64, tag = "1")]
    pub scheduled_event_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartTimerCommandAttributes {
    /// An id for the timer, currently live timers must have different ids. Typically autogenerated
    /// by the SDK.
    #[prost(string, tag = "1")]
    pub timer_id: ::prost::alloc::string::String,
    /// How long until the timer fires, producing a `TIMER_FIRED` event.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: "to" is used to indicate interval. --)
    #[prost(message, optional, tag = "2")]
    pub start_to_fire_timeout: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteWorkflowExecutionCommandAttributes {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::super::common::v1::Payloads>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailWorkflowExecutionCommandAttributes {
    #[prost(message, optional, tag = "1")]
    pub failure: ::core::option::Option<super::super::failure::v1::Failure>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTimerCommandAttributes {
    /// The same timer id from the start timer command
    #[prost(string, tag = "1")]
    pub timer_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelWorkflowExecutionCommandAttributes {
    #[prost(message, optional, tag = "1")]
    pub details: ::core::option::Option<super::super::common::v1::Payloads>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestCancelExternalWorkflowExecutionCommandAttributes {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub run_id: ::prost::alloc::string::String,
    /// Deprecated.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub control: ::prost::alloc::string::String,
    /// Set this to true if the workflow being cancelled is a child of the workflow originating this
    /// command. The request will be rejected if it is set to true and the target workflow is *not*
    /// a child of the requesting workflow.
    #[prost(bool, tag = "5")]
    pub child_workflow_only: bool,
    /// Reason for requesting the cancellation
    #[prost(string, tag = "6")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalExternalWorkflowExecutionCommandAttributes {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub execution: ::core::option::Option<super::super::common::v1::WorkflowExecution>,
    /// The workflow author-defined name of the signal to send to the workflow.
    #[prost(string, tag = "3")]
    pub signal_name: ::prost::alloc::string::String,
    /// Serialized value(s) to provide with the signal.
    #[prost(message, optional, tag = "4")]
    pub input: ::core::option::Option<super::super::common::v1::Payloads>,
    /// Deprecated
    #[deprecated]
    #[prost(string, tag = "5")]
    pub control: ::prost::alloc::string::String,
    /// Set this to true if the workflow being cancelled is a child of the workflow originating this
    /// command. The request will be rejected if it is set to true and the target workflow is *not*
    /// a child of the requesting workflow.
    #[prost(bool, tag = "6")]
    pub child_workflow_only: bool,
    /// Headers that are passed by the workflow that is sending a signal to the external
    /// workflow that is receiving this signal.
    #[prost(message, optional, tag = "7")]
    pub header: ::core::option::Option<super::super::common::v1::Header>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertWorkflowSearchAttributesCommandAttributes {
    #[prost(message, optional, tag = "1")]
    pub search_attributes: ::core::option::Option<
        super::super::common::v1::SearchAttributes,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModifyWorkflowPropertiesCommandAttributes {
    /// If set, update the workflow memo with the provided values. The values will be merged with
    /// the existing memo. If the user wants to delete values, a default/empty Payload should be
    /// used as the value for the key being deleted.
    #[prost(message, optional, tag = "1")]
    pub upserted_memo: ::core::option::Option<super::super::common::v1::Memo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordMarkerCommandAttributes {
    #[prost(string, tag = "1")]
    pub marker_name: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "2")]
    pub details: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::common::v1::Payloads,
    >,
    #[prost(message, optional, tag = "3")]
    pub header: ::core::option::Option<super::super::common::v1::Header>,
    #[prost(message, optional, tag = "4")]
    pub failure: ::core::option::Option<super::super::failure::v1::Failure>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContinueAsNewWorkflowExecutionCommandAttributes {
    #[prost(message, optional, tag = "1")]
    pub workflow_type: ::core::option::Option<super::super::common::v1::WorkflowType>,
    #[prost(message, optional, tag = "2")]
    pub task_queue: ::core::option::Option<super::super::taskqueue::v1::TaskQueue>,
    #[prost(message, optional, tag = "3")]
    pub input: ::core::option::Option<super::super::common::v1::Payloads>,
    /// Timeout of a single workflow run.
    #[prost(message, optional, tag = "4")]
    pub workflow_run_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Timeout of a single workflow task.
    #[prost(message, optional, tag = "5")]
    pub workflow_task_timeout: ::core::option::Option<::prost_types::Duration>,
    /// How long the workflow start will be delayed - not really a "backoff" in the traditional sense.
    #[prost(message, optional, tag = "6")]
    pub backoff_start_interval: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "7")]
    pub retry_policy: ::core::option::Option<super::super::common::v1::RetryPolicy>,
    /// Should be removed
    #[prost(enumeration = "super::super::enums::v1::ContinueAsNewInitiator", tag = "8")]
    pub initiator: i32,
    /// Should be removed
    #[prost(message, optional, tag = "9")]
    pub failure: ::core::option::Option<super::super::failure::v1::Failure>,
    /// Should be removed
    #[prost(message, optional, tag = "10")]
    pub last_completion_result: ::core::option::Option<
        super::super::common::v1::Payloads,
    >,
    /// Should be removed. Not necessarily unused but unclear and not exposed by SDKs.
    #[prost(string, tag = "11")]
    pub cron_schedule: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub header: ::core::option::Option<super::super::common::v1::Header>,
    #[prost(message, optional, tag = "13")]
    pub memo: ::core::option::Option<super::super::common::v1::Memo>,
    #[prost(message, optional, tag = "14")]
    pub search_attributes: ::core::option::Option<
        super::super::common::v1::SearchAttributes,
    >,
    /// If this is set, the new execution inherits the Build ID of the current execution. Otherwise,
    /// the assignment rules will be used to independently assign a Build ID to the new execution.
    /// Deprecated. Only considered for versioning v0.2.
    #[deprecated]
    #[prost(bool, tag = "15")]
    pub inherit_build_id: bool,
    /// Experimental. Optionally decide the versioning behavior that the first task of the new run should use.
    /// For example, choose to AutoUpgrade on continue-as-new instead of inheriting the pinned version
    /// of the previous run.
    #[prost(
        enumeration = "super::super::enums::v1::ContinueAsNewVersioningBehavior",
        tag = "16"
    )]
    pub initial_versioning_behavior: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartChildWorkflowExecutionCommandAttributes {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<super::super::common::v1::WorkflowType>,
    #[prost(message, optional, tag = "4")]
    pub task_queue: ::core::option::Option<super::super::taskqueue::v1::TaskQueue>,
    #[prost(message, optional, tag = "5")]
    pub input: ::core::option::Option<super::super::common::v1::Payloads>,
    /// Total workflow execution timeout including retries and continue as new.
    #[prost(message, optional, tag = "6")]
    pub workflow_execution_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Timeout of a single workflow run.
    #[prost(message, optional, tag = "7")]
    pub workflow_run_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Timeout of a single workflow task.
    #[prost(message, optional, tag = "8")]
    pub workflow_task_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Default: PARENT_CLOSE_POLICY_TERMINATE.
    #[prost(enumeration = "super::super::enums::v1::ParentClosePolicy", tag = "9")]
    pub parent_close_policy: i32,
    #[prost(string, tag = "10")]
    pub control: ::prost::alloc::string::String,
    /// Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    #[prost(enumeration = "super::super::enums::v1::WorkflowIdReusePolicy", tag = "11")]
    pub workflow_id_reuse_policy: i32,
    #[prost(message, optional, tag = "12")]
    pub retry_policy: ::core::option::Option<super::super::common::v1::RetryPolicy>,
    /// Establish a cron schedule for the child workflow.
    #[prost(string, tag = "13")]
    pub cron_schedule: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "14")]
    pub header: ::core::option::Option<super::super::common::v1::Header>,
    #[prost(message, optional, tag = "15")]
    pub memo: ::core::option::Option<super::super::common::v1::Memo>,
    #[prost(message, optional, tag = "16")]
    pub search_attributes: ::core::option::Option<
        super::super::common::v1::SearchAttributes,
    >,
    /// If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment
    /// rules of the child's Task Queue will be used to independently assign a Build ID to it.
    /// Deprecated. Only considered for versioning v0.2.
    #[deprecated]
    #[prost(bool, tag = "17")]
    pub inherit_build_id: bool,
    /// Priority metadata. If this message is not present, or any fields are not
    /// present, they inherit the values from the workflow.
    #[prost(message, optional, tag = "18")]
    pub priority: ::core::option::Option<super::super::common::v1::Priority>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtocolMessageCommandAttributes {
    /// The message ID of the message to which this command is a pointer.
    #[prost(string, tag = "1")]
    pub message_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleNexusOperationCommandAttributes {
    /// Endpoint name, must exist in the endpoint registry or this command will fail.
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    /// Service name.
    #[prost(string, tag = "2")]
    pub service: ::prost::alloc::string::String,
    /// Operation name.
    #[prost(string, tag = "3")]
    pub operation: ::prost::alloc::string::String,
    /// Input for the operation. The server converts this into Nexus request content and the appropriate content headers
    /// internally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the
    /// content is transformed back to the original Payload sent in this command.
    #[prost(message, optional, tag = "4")]
    pub input: ::core::option::Option<super::super::common::v1::Payload>,
    /// Schedule-to-close timeout for this operation.
    /// Indicates how long the caller is willing to wait for operation completion.
    /// Calls are retried internally by the server.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: "to" is used to indicate interval. --)
    #[prost(message, optional, tag = "5")]
    pub schedule_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Header to attach to the Nexus request.
    /// Users are responsible for encrypting sensitive data in this header as it is stored in workflow history and
    /// transmitted to external services as-is.
    /// This is useful for propagating tracing information.
    /// Note these headers are not the same as Temporal headers on internal activities and child workflows, these are
    /// transmitted to Nexus operations that may be external and are not traditional payloads.
    #[prost(map = "string, string", tag = "6")]
    pub nexus_header: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Schedule-to-start timeout for this operation.
    /// Indicates how long the caller is willing to wait for the operation to be started (or completed if synchronous)
    /// by the handler. If the operation is not started within this timeout, it will fail with
    /// TIMEOUT_TYPE_SCHEDULE_TO_START.
    /// If not set or zero, no schedule-to-start timeout is enforced.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: "to" is used to indicate interval. --)
    /// Requires server version 1.31.0 or later.
    #[prost(message, optional, tag = "7")]
    pub schedule_to_start_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Start-to-close timeout for this operation.
    /// Indicates how long the caller is willing to wait for an asynchronous operation to complete after it has been
    /// started. If the operation does not complete within this timeout after starting, it will fail with
    /// TIMEOUT_TYPE_START_TO_CLOSE.
    /// Only applies to asynchronous operations. Synchronous operations ignore this timeout.
    /// If not set or zero, no start-to-close timeout is enforced.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: "to" is used to indicate interval. --)
    /// Requires server version 1.31.0 or later.
    #[prost(message, optional, tag = "8")]
    pub start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestCancelNexusOperationCommandAttributes {
    /// The `NEXUS_OPERATION_SCHEDULED` event ID (a unique identifier) for the operation to be canceled.
    /// The operation may ignore cancellation and end up with any completion state.
    #[prost(int64, tag = "1")]
    pub scheduled_event_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Command {
    #[prost(enumeration = "super::super::enums::v1::CommandType", tag = "1")]
    pub command_type: i32,
    /// Metadata on the command. This is sometimes carried over to the history event if one is
    /// created as a result of the command. Most commands won't have this information, and how this
    /// information is used is dependent upon the interface that reads it.
    ///
    /// Current well-known uses:
    ///   * start_child_workflow_execution_command_attributes - populates
    ///     temporal.api.workflow.v1.WorkflowExecutionInfo.user_metadata where the summary and details
    ///     are used by user interfaces to show fixed as-of-start workflow summary and details.
    ///   * start_timer_command_attributes - populates temporal.api.history.v1.HistoryEvent for timer
    ///     started where the summary is used to identify the timer.
    #[prost(message, optional, tag = "301")]
    pub user_metadata: ::core::option::Option<super::super::sdk::v1::UserMetadata>,
    /// The command details. The type must match that in `command_type`.
    #[prost(
        oneof = "command::Attributes",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19"
    )]
    pub attributes: ::core::option::Option<command::Attributes>,
}
/// Nested message and enum types in `Command`.
pub mod command {
    /// The command details. The type must match that in `command_type`.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Attributes {
        #[prost(message, tag = "2")]
        ScheduleActivityTaskCommandAttributes(
            super::ScheduleActivityTaskCommandAttributes,
        ),
        #[prost(message, tag = "3")]
        StartTimerCommandAttributes(super::StartTimerCommandAttributes),
        #[prost(message, tag = "4")]
        CompleteWorkflowExecutionCommandAttributes(
            super::CompleteWorkflowExecutionCommandAttributes,
        ),
        #[prost(message, tag = "5")]
        FailWorkflowExecutionCommandAttributes(
            super::FailWorkflowExecutionCommandAttributes,
        ),
        #[prost(message, tag = "6")]
        RequestCancelActivityTaskCommandAttributes(
            super::RequestCancelActivityTaskCommandAttributes,
        ),
        #[prost(message, tag = "7")]
        CancelTimerCommandAttributes(super::CancelTimerCommandAttributes),
        #[prost(message, tag = "8")]
        CancelWorkflowExecutionCommandAttributes(
            super::CancelWorkflowExecutionCommandAttributes,
        ),
        #[prost(message, tag = "9")]
        RequestCancelExternalWorkflowExecutionCommandAttributes(
            super::RequestCancelExternalWorkflowExecutionCommandAttributes,
        ),
        #[prost(message, tag = "10")]
        RecordMarkerCommandAttributes(super::RecordMarkerCommandAttributes),
        #[prost(message, tag = "11")]
        ContinueAsNewWorkflowExecutionCommandAttributes(
            super::ContinueAsNewWorkflowExecutionCommandAttributes,
        ),
        #[prost(message, tag = "12")]
        StartChildWorkflowExecutionCommandAttributes(
            super::StartChildWorkflowExecutionCommandAttributes,
        ),
        #[prost(message, tag = "13")]
        SignalExternalWorkflowExecutionCommandAttributes(
            super::SignalExternalWorkflowExecutionCommandAttributes,
        ),
        #[prost(message, tag = "14")]
        UpsertWorkflowSearchAttributesCommandAttributes(
            super::UpsertWorkflowSearchAttributesCommandAttributes,
        ),
        #[prost(message, tag = "15")]
        ProtocolMessageCommandAttributes(super::ProtocolMessageCommandAttributes),
        /// 16 is available for use - it was used as part of a prototype that never made it into a release
        #[prost(message, tag = "17")]
        ModifyWorkflowPropertiesCommandAttributes(
            super::ModifyWorkflowPropertiesCommandAttributes,
        ),
        #[prost(message, tag = "18")]
        ScheduleNexusOperationCommandAttributes(
            super::ScheduleNexusOperationCommandAttributes,
        ),
        #[prost(message, tag = "19")]
        RequestCancelNexusOperationCommandAttributes(
            super::RequestCancelNexusOperationCommandAttributes,
        ),
    }
}
