// This file is @generated by prost-build.
/// CalendarSpec describes an event specification relative to the calendar,
/// similar to a traditional cron specification, but with labeled fields. Each
/// field can be one of:
///    *: matches always
///    x: matches when the field equals x
///    x/y : matches when the field equals x+n*y where n is an integer
///    x-z: matches when the field is between x and z inclusive
///    w,x,y,...: matches when the field is one of the listed values
/// Each x, y, z, ... is either a decimal integer, or a month or day of week name
/// or abbreviation (in the appropriate fields).
/// A timestamp matches if all fields match.
/// Note that fields have different default values, for convenience.
/// Note that the special case that some cron implementations have for treating
/// day_of_month and day_of_week as "or" instead of "and" when both are set is
/// not implemented.
/// day_of_week can accept 0 or 7 as Sunday
/// CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be
/// returned if you describe the schedule.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalendarSpec {
    /// Expression to match seconds. Default: 0
    #[prost(string, tag = "1")]
    pub second: ::prost::alloc::string::String,
    /// Expression to match minutes. Default: 0
    #[prost(string, tag = "2")]
    pub minute: ::prost::alloc::string::String,
    /// Expression to match hours. Default: 0
    #[prost(string, tag = "3")]
    pub hour: ::prost::alloc::string::String,
    /// Expression to match days of the month. Default: *
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: standard name of field --)
    #[prost(string, tag = "4")]
    pub day_of_month: ::prost::alloc::string::String,
    /// Expression to match months. Default: *
    #[prost(string, tag = "5")]
    pub month: ::prost::alloc::string::String,
    /// Expression to match years. Default: *
    #[prost(string, tag = "6")]
    pub year: ::prost::alloc::string::String,
    /// Expression to match days of the week. Default: *
    #[prost(string, tag = "7")]
    pub day_of_week: ::prost::alloc::string::String,
    /// Free-form comment describing the intention of this spec.
    #[prost(string, tag = "8")]
    pub comment: ::prost::alloc::string::String,
}
/// Range represents a set of integer values, used to match fields of a calendar
/// time in StructuredCalendarSpec. If end < start, then end is interpreted as
/// equal to start. This means you can use a Range with start set to a value, and
/// end and step unset (defaulting to 0) to represent a single value.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Range {
    /// Start of range (inclusive).
    #[prost(int32, tag = "1")]
    pub start: i32,
    /// End of range (inclusive).
    #[prost(int32, tag = "2")]
    pub end: i32,
    /// Step (optional, default 1).
    #[prost(int32, tag = "3")]
    pub step: i32,
}
/// StructuredCalendarSpec describes an event specification relative to the
/// calendar, in a form that's easy to work with programmatically. Each field can
/// be one or more ranges.
/// A timestamp matches if at least one range of each field matches the
/// corresponding fields of the timestamp, except for year: if year is missing,
/// that means all years match. For all fields besides year, at least one Range
/// must be present to match anything.
/// Relative expressions such as "last day of the month" or "third Monday" are not currently
/// representable; callers must enumerate the concrete days they require.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructuredCalendarSpec {
    /// Match seconds (0-59)
    #[prost(message, repeated, tag = "1")]
    pub second: ::prost::alloc::vec::Vec<Range>,
    /// Match minutes (0-59)
    #[prost(message, repeated, tag = "2")]
    pub minute: ::prost::alloc::vec::Vec<Range>,
    /// Match hours (0-23)
    #[prost(message, repeated, tag = "3")]
    pub hour: ::prost::alloc::vec::Vec<Range>,
    /// Match days of the month (1-31)
    /// (-- api-linter: core::0140::prepositions=disabled
    ///      aip.dev/not-precedent: standard name of field --)
    #[prost(message, repeated, tag = "4")]
    pub day_of_month: ::prost::alloc::vec::Vec<Range>,
    /// Match months (1-12)
    #[prost(message, repeated, tag = "5")]
    pub month: ::prost::alloc::vec::Vec<Range>,
    /// Match years.
    #[prost(message, repeated, tag = "6")]
    pub year: ::prost::alloc::vec::Vec<Range>,
    /// Match days of the week (0-6; 0 is Sunday).
    #[prost(message, repeated, tag = "7")]
    pub day_of_week: ::prost::alloc::vec::Vec<Range>,
    /// Free-form comment describing the intention of this spec.
    #[prost(string, tag = "8")]
    pub comment: ::prost::alloc::string::String,
}
/// IntervalSpec matches times that can be expressed as:
/// epoch + n * interval + phase
/// where n is an integer.
/// phase defaults to zero if missing. interval is required.
/// Both interval and phase must be non-negative and are truncated to the nearest
/// second before any calculations.
/// For example, an interval of 1 hour with phase of zero would match every hour,
/// on the hour. The same interval but a phase of 19 minutes would match every
/// xx:19:00. An interval of 28 days with phase zero would match
/// 2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
/// days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IntervalSpec {
    #[prost(message, optional, tag = "1")]
    pub interval: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "2")]
    pub phase: ::core::option::Option<::prost_types::Duration>,
}
/// ScheduleSpec is a complete description of a set of absolute timestamps
/// (possibly infinite) that an action should occur at. The meaning of a
/// ScheduleSpec depends only on its contents and never changes, except that the
/// definition of a time zone can change over time (most commonly, when daylight
/// saving time policy changes for an area). To create a totally self-contained
/// ScheduleSpec, use UTC or include timezone_data.
///
/// For input, you can provide zero or more of: structured_calendar, calendar,
/// cron_string, interval, and exclude_structured_calendar, and all of them will
/// be used (the schedule will take action at the union of all of their times,
/// minus the ones that match exclude_structured_calendar).
///
/// On input, calendar and cron_string fields will be compiled into
/// structured_calendar (and maybe interval and timezone_name), so if you
/// Describe a schedule, you'll see only structured_calendar, interval, etc.
///
/// If a spec has no matching times after the current time, then the schedule
/// will be subject to automatic deletion (after several days).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleSpec {
    /// Calendar-based specifications of times.
    #[prost(message, repeated, tag = "7")]
    pub structured_calendar: ::prost::alloc::vec::Vec<StructuredCalendarSpec>,
    /// cron_string holds a traditional cron specification as a string. It
    /// accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
    /// same way as CalendarSpec.
    /// 5 fields:         minute, hour, day_of_month, month, day_of_week
    /// 6 fields:         minute, hour, day_of_month, month, day_of_week, year
    /// 7 fields: second, minute, hour, day_of_month, month, day_of_week, year
    /// If year is not given, it defaults to *. If second is not given, it
    /// defaults to 0.
    /// Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
    /// accepted instead of the 5-7 time fields.
    /// Optionally, the string can be preceded by CRON_TZ=<timezone name> or
    /// TZ=<timezone name>, which will get copied to timezone_name. (There must
    /// not also be a timezone_name present.)
    /// Optionally "#" followed by a comment can appear at the end of the string.
    /// Note that the special case that some cron implementations have for
    /// treating day_of_month and day_of_week as "or" instead of "and" when both
    /// are set is not implemented.
    /// @every <interval>\[/<phase>\] is accepted and gets compiled into an
    /// IntervalSpec instead. <interval> and <phase> should be a decimal integer
    /// with a unit suffix s, m, h, or d.
    #[prost(string, repeated, tag = "8")]
    pub cron_string: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Calendar-based specifications of times.
    #[prost(message, repeated, tag = "1")]
    pub calendar: ::prost::alloc::vec::Vec<CalendarSpec>,
    /// Interval-based specifications of times.
    #[prost(message, repeated, tag = "2")]
    pub interval: ::prost::alloc::vec::Vec<IntervalSpec>,
    /// Any timestamps matching any of exclude_* will be skipped.
    /// Deprecated. Use exclude_structured_calendar.
    #[deprecated]
    #[prost(message, repeated, tag = "3")]
    pub exclude_calendar: ::prost::alloc::vec::Vec<CalendarSpec>,
    #[prost(message, repeated, tag = "9")]
    pub exclude_structured_calendar: ::prost::alloc::vec::Vec<StructuredCalendarSpec>,
    /// If start_time is set, any timestamps before start_time will be skipped.
    /// (Together, start_time and end_time make an inclusive interval.)
    #[prost(message, optional, tag = "4")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// If end_time is set, any timestamps after end_time will be skipped.
    #[prost(message, optional, tag = "5")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// All timestamps will be incremented by a random value from 0 to this
    /// amount of jitter. Default: 0
    #[prost(message, optional, tag = "6")]
    pub jitter: ::core::option::Option<::prost_types::Duration>,
    /// Time zone to interpret all calendar-based specs in.
    ///
    /// If unset, defaults to UTC. We recommend using UTC for your application if
    /// at all possible, to avoid various surprising properties of time zones.
    ///
    /// Time zones may be provided by name, corresponding to names in the IANA
    /// time zone database (see <https://www.iana.org/time-zones>). The definition
    /// will be loaded by the Temporal server from the environment it runs in.
    ///
    /// If your application requires more control over the time zone definition
    /// used, it may pass in a complete definition in the form of a TZif file
    /// from the time zone database. If present, this will be used instead of
    /// loading anything from the environment. You are then responsible for
    /// updating timezone_data when the definition changes.
    ///
    /// Calendar spec matching is based on literal matching of the clock time
    /// with no special handling of DST: if you write a calendar spec that fires
    /// at 2:30am and specify a time zone that follows DST, that action will not
    /// be triggered on the day that has no 2:30am. Similarly, an action that
    /// fires at 1:30am will be triggered twice on the day that has two 1:30s.
    ///
    /// Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
    #[prost(string, tag = "10")]
    pub timezone_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "11")]
    pub timezone_data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SchedulePolicies {
    /// Policy for overlaps.
    /// Note that this can be changed after a schedule has taken some actions,
    /// and some changes might produce unintuitive results. In general, the later
    /// policy overrides the earlier policy.
    #[prost(enumeration = "super::super::enums::v1::ScheduleOverlapPolicy", tag = "1")]
    pub overlap_policy: i32,
    /// Policy for catchups:
    /// If the Temporal server misses an action due to one or more components
    /// being down, and comes back up, the action will be run if the scheduled
    /// time is within this window from the current time.
    /// This value defaults to one year, and can't be less than 10 seconds.
    #[prost(message, optional, tag = "2")]
    pub catchup_window: ::core::option::Option<::prost_types::Duration>,
    /// If true, and a workflow run fails or times out, turn on "paused".
    /// This applies after retry policies: the full chain of retries must fail to
    /// trigger a pause here.
    #[prost(bool, tag = "3")]
    pub pause_on_failure: bool,
    /// If true, and the action would start a workflow, a timestamp will not be
    /// appended to the scheduled workflow id.
    #[prost(bool, tag = "4")]
    pub keep_original_workflow_id: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleAction {
    #[prost(oneof = "schedule_action::Action", tags = "1")]
    pub action: ::core::option::Option<schedule_action::Action>,
}
/// Nested message and enum types in `ScheduleAction`.
pub mod schedule_action {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        /// All fields of NewWorkflowExecutionInfo are valid except for:
        /// - workflow_id_reuse_policy
        /// - cron_schedule
        /// The workflow id of the started workflow may not match this exactly,
        /// it may have a timestamp appended for uniqueness.
        #[prost(message, tag = "1")]
        StartWorkflow(super::super::super::workflow::v1::NewWorkflowExecutionInfo),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleActionResult {
    /// Time that the action was taken (according to the schedule, including jitter).
    #[prost(message, optional, tag = "1")]
    pub schedule_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Time that the action was taken (real time).
    #[prost(message, optional, tag = "2")]
    pub actual_time: ::core::option::Option<::prost_types::Timestamp>,
    /// If action was start_workflow:
    #[prost(message, optional, tag = "11")]
    pub start_workflow_result: ::core::option::Option<
        super::super::common::v1::WorkflowExecution,
    >,
    /// If the action was start_workflow, this field will reflect an
    /// eventually-consistent view of the started workflow's status.
    #[prost(
        enumeration = "super::super::enums::v1::WorkflowExecutionStatus",
        tag = "12"
    )]
    pub start_workflow_status: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleState {
    /// Informative human-readable message with contextual notes, e.g. the reason
    /// a schedule is paused. The system may overwrite this message on certain
    /// conditions, e.g. when pause-on-failure happens.
    #[prost(string, tag = "1")]
    pub notes: ::prost::alloc::string::String,
    /// If true, do not take any actions based on the schedule spec.
    #[prost(bool, tag = "2")]
    pub paused: bool,
    /// If limited_actions is true, decrement remaining_actions after each
    /// action, and do not take any more scheduled actions if remaining_actions
    /// is zero. Actions may still be taken by explicit request (i.e. trigger
    /// immediately or backfill). Skipped actions (due to overlap policy) do not
    /// count against remaining actions.
    /// If a schedule has no more remaining actions, then the schedule will be
    /// subject to automatic deletion (after several days).
    #[prost(bool, tag = "3")]
    pub limited_actions: bool,
    #[prost(int64, tag = "4")]
    pub remaining_actions: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TriggerImmediatelyRequest {
    /// If set, override overlap policy for this one request.
    #[prost(enumeration = "super::super::enums::v1::ScheduleOverlapPolicy", tag = "1")]
    pub overlap_policy: i32,
    /// Timestamp used for the identity of the target workflow.
    /// If not set the default value is the current time.
    #[prost(message, optional, tag = "2")]
    pub scheduled_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackfillRequest {
    /// Time range to evaluate schedule in. Currently, this time range is
    /// exclusive on start_time and inclusive on end_time. (This is admittedly
    /// counterintuitive and it may change in the future, so to be safe, use a
    /// start time strictly before a scheduled time.) Also note that an action
    /// nominally scheduled in the interval but with jitter that pushes it after
    /// end_time will not be included.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// If set, override overlap policy for this request.
    #[prost(enumeration = "super::super::enums::v1::ScheduleOverlapPolicy", tag = "3")]
    pub overlap_policy: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedulePatch {
    /// If set, trigger one action immediately.
    #[prost(message, optional, tag = "1")]
    pub trigger_immediately: ::core::option::Option<TriggerImmediatelyRequest>,
    /// If set, runs though the specified time period(s) and takes actions as if that time
    /// passed by right now, all at once. The overlap policy can be overridden for the
    /// scope of the backfill.
    #[prost(message, repeated, tag = "2")]
    pub backfill_request: ::prost::alloc::vec::Vec<BackfillRequest>,
    /// If set, change the state to paused or unpaused (respectively) and set the
    /// notes field to the value of the string.
    #[prost(string, tag = "3")]
    pub pause: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub unpause: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleInfo {
    /// Number of actions taken so far.
    #[prost(int64, tag = "1")]
    pub action_count: i64,
    /// Number of times a scheduled action was skipped due to missing the catchup window.
    #[prost(int64, tag = "2")]
    pub missed_catchup_window: i64,
    /// Number of skipped actions due to overlap.
    #[prost(int64, tag = "3")]
    pub overlap_skipped: i64,
    /// Number of dropped actions due to buffer limit.
    #[prost(int64, tag = "10")]
    pub buffer_dropped: i64,
    /// Number of actions in the buffer. The buffer holds the actions that cannot
    /// be immediately triggered (due to the overlap policy). These actions can be a result of
    /// the normal schedule or a backfill.
    #[prost(int64, tag = "11")]
    pub buffer_size: i64,
    /// Currently-running workflows started by this schedule. (There might be
    /// more than one if the overlap policy allows overlaps.)
    /// Note that the run_ids in here are the original execution run ids as
    /// started by the schedule. If the workflows retried, did continue-as-new,
    /// or were reset, they might still be running but with a different run_id.
    #[prost(message, repeated, tag = "9")]
    pub running_workflows: ::prost::alloc::vec::Vec<
        super::super::common::v1::WorkflowExecution,
    >,
    /// Most recent ten actual action times (including manual triggers).
    #[prost(message, repeated, tag = "4")]
    pub recent_actions: ::prost::alloc::vec::Vec<ScheduleActionResult>,
    /// Next ten scheduled action times.
    #[prost(message, repeated, tag = "5")]
    pub future_action_times: ::prost::alloc::vec::Vec<::prost_types::Timestamp>,
    /// Timestamps of schedule creation and last update.
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Deprecated.
    #[deprecated]
    #[prost(string, tag = "8")]
    pub invalid_schedule_error: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schedule {
    #[prost(message, optional, tag = "1")]
    pub spec: ::core::option::Option<ScheduleSpec>,
    #[prost(message, optional, tag = "2")]
    pub action: ::core::option::Option<ScheduleAction>,
    #[prost(message, optional, tag = "3")]
    pub policies: ::core::option::Option<SchedulePolicies>,
    #[prost(message, optional, tag = "4")]
    pub state: ::core::option::Option<ScheduleState>,
}
/// ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
/// that's returned in ListSchedules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleListInfo {
    /// From spec:
    /// Some fields are dropped from this copy of spec: timezone_data
    #[prost(message, optional, tag = "1")]
    pub spec: ::core::option::Option<ScheduleSpec>,
    /// From action:
    /// Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
    /// well with JSON. If action is start_workflow, this is set:
    #[prost(message, optional, tag = "2")]
    pub workflow_type: ::core::option::Option<super::super::common::v1::WorkflowType>,
    /// From state:
    #[prost(string, tag = "3")]
    pub notes: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub paused: bool,
    /// From info (maybe fewer entries):
    #[prost(message, repeated, tag = "5")]
    pub recent_actions: ::prost::alloc::vec::Vec<ScheduleActionResult>,
    #[prost(message, repeated, tag = "6")]
    pub future_action_times: ::prost::alloc::vec::Vec<::prost_types::Timestamp>,
}
/// ScheduleListEntry is returned by ListSchedules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleListEntry {
    #[prost(string, tag = "1")]
    pub schedule_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub memo: ::core::option::Option<super::super::common::v1::Memo>,
    #[prost(message, optional, tag = "3")]
    pub search_attributes: ::core::option::Option<
        super::super::common::v1::SearchAttributes,
    >,
    #[prost(message, optional, tag = "4")]
    pub info: ::core::option::Option<ScheduleListInfo>,
}
