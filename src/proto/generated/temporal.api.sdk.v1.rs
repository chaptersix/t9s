// This file is @generated by prost-build.
/// Information a user can set, often for use by user interfaces.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserMetadata {
    /// Short-form text that provides a summary. This payload should be a "json/plain"-encoded payload
    /// that is a single JSON string for use in user interfaces. User interface formatting may not
    /// apply to this text when used in "title" situations. The payload data section is limited to 400
    /// bytes by default.
    #[prost(message, optional, tag = "1")]
    pub summary: ::core::option::Option<super::super::common::v1::Payload>,
    /// Long-form text that provides details. This payload should be a "json/plain"-encoded payload
    /// that is a single JSON string for use in user interfaces. User interface formatting may apply to
    /// this text in common use. The payload data section is limited to 20000 bytes by default.
    #[prost(message, optional, tag = "2")]
    pub details: ::core::option::Option<super::super::common::v1::Payload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowTaskCompletedMetadata {
    /// Internal flags used by the core SDK. SDKs using flags must comply with the following behavior:
    ///
    /// During replay:
    /// * If a flag is not recognized (value is too high or not defined), it must fail the workflow
    ///    task.
    /// * If a flag is recognized, it is stored in a set of used flags for the run. Code checks for
    ///    that flag during and after this WFT are allowed to assume that the flag is present.
    /// * If a code check for a flag does not find the flag in the set of used flags, it must take
    ///    the branch corresponding to the absence of that flag.
    ///
    /// During non-replay execution of new WFTs:
    /// * The SDK is free to use all flags it knows about. It must record any newly-used (IE: not
    ///    previously recorded) flags when completing the WFT.
    ///
    /// SDKs which are too old to even know about this field at all are considered to produce
    /// undefined behavior if they replay workflows which used this mechanism.
    ///
    /// (-- api-linter: core::0141::forbidden-types=disabled
    ///      aip.dev/not-precedent: These really shouldn't have negative values. --)
    #[prost(uint32, repeated, tag = "1")]
    pub core_used_flags: ::prost::alloc::vec::Vec<u32>,
    /// Flags used by the SDK lang. No attempt is made to distinguish between different SDK languages
    /// here as processing a workflow with a different language than the one which authored it is
    /// already undefined behavior. See `core_used_patches` for more.
    ///
    /// (-- api-linter: core::0141::forbidden-types=disabled
    ///      aip.dev/not-precedent: These really shouldn't have negative values. --)
    #[prost(uint32, repeated, tag = "2")]
    pub lang_used_flags: ::prost::alloc::vec::Vec<u32>,
    /// Name of the SDK that processed the task. This is usually something like "temporal-go" and is
    /// usually the same as client-name gRPC header. This should only be set if its value changed
    /// since the last time recorded on the workflow (or be set on the first task).
    ///
    /// (-- api-linter: core::0122::name-suffix=disabled
    ///      aip.dev/not-precedent: We're ok with a name suffix here. --)
    #[prost(string, tag = "3")]
    pub sdk_name: ::prost::alloc::string::String,
    /// Version of the SDK that processed the task. This is usually something like "1.20.0" and is
    /// usually the same as client-version gRPC header. This should only be set if its value changed
    /// since the last time recorded on the workflow (or be set on the first task).
    #[prost(string, tag = "4")]
    pub sdk_version: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorkerConfig {
    #[prost(int32, tag = "1")]
    pub workflow_cache_size: i32,
    #[prost(oneof = "worker_config::PollerBehavior", tags = "2, 3")]
    pub poller_behavior: ::core::option::Option<worker_config::PollerBehavior>,
}
/// Nested message and enum types in `WorkerConfig`.
pub mod worker_config {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SimplePollerBehavior {
        #[prost(int32, tag = "1")]
        pub max_pollers: i32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AutoscalingPollerBehavior {
        /// At least this many poll calls will always be attempted (assuming slots are available).
        /// Cannot be zero.
        #[prost(int32, tag = "1")]
        pub min_pollers: i32,
        /// At most this many poll calls will ever be open at once. Must be >= `minimum`.
        #[prost(int32, tag = "2")]
        pub max_pollers: i32,
        /// This many polls will be attempted initially before scaling kicks in. Must be between
        ///   `minimum` and `maximum`.
        #[prost(int32, tag = "3")]
        pub initial_pollers: i32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum PollerBehavior {
        #[prost(message, tag = "2")]
        SimplePollerBehavior(SimplePollerBehavior),
        #[prost(message, tag = "3")]
        AutoscalingPollerBehavior(AutoscalingPollerBehavior),
    }
}
