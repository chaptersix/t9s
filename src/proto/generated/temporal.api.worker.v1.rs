// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorkerPollerInfo {
    /// Number of polling RPCs that are currently in flight.
    #[prost(int32, tag = "1")]
    pub current_pollers: i32,
    #[prost(message, optional, tag = "2")]
    pub last_successful_poll_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Set true if the number of concurrent pollers is auto-scaled
    #[prost(bool, tag = "3")]
    pub is_autoscaling: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerSlotsInfo {
    /// Number of slots available for the worker to specific tasks.
    /// May be -1 if the upper bound is not known.
    #[prost(int32, tag = "1")]
    pub current_available_slots: i32,
    /// Number of slots used by the worker for specific tasks.
    #[prost(int32, tag = "2")]
    pub current_used_slots: i32,
    /// Kind of the slot supplier, which is used to determine how the slots are allocated.
    /// Possible values: "Fixed | ResourceBased | Custom String"
    #[prost(string, tag = "3")]
    pub slot_supplier_kind: ::prost::alloc::string::String,
    /// Total number of tasks processed (completed both successfully and unsuccesfully, or any other way)
    /// by the worker since the worker started. This is a cumulative counter.
    #[prost(int32, tag = "4")]
    pub total_processed_tasks: i32,
    /// Total number of failed tasks processed by the worker so far.
    #[prost(int32, tag = "5")]
    pub total_failed_tasks: i32,
    /// Number of tasks processed in since the last heartbeat from the worker.
    /// This is a cumulative counter, and it is reset to 0 each time the worker sends a heartbeat.
    /// Contains both successful and failed tasks.
    #[prost(int32, tag = "6")]
    pub last_interval_processed_tasks: i32,
    /// Number of failed tasks processed since the last heartbeat from the worker.
    #[prost(int32, tag = "7")]
    pub last_interval_failure_tasks: i32,
}
/// Holds everything needed to identify the worker host/process context
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerHostInfo {
    /// Worker host identifier.
    #[prost(string, tag = "1")]
    pub host_name: ::prost::alloc::string::String,
    /// Worker grouping identifier. A key to group workers that share the same client+namespace+process.
    /// This will be used to build the worker command nexus task queue name:
    /// "temporal-sys/worker-commands/{worker_grouping_key}"
    #[prost(string, tag = "5")]
    pub worker_grouping_key: ::prost::alloc::string::String,
    /// Worker process identifier. This id only needs to be unique
    /// within one host (so using e.g. a unix pid would be appropriate).
    #[prost(string, tag = "2")]
    pub process_id: ::prost::alloc::string::String,
    /// System used CPU as a float in the range \[0.0, 1.0\] where 1.0 is defined as all
    /// cores on the host pegged.
    #[prost(float, tag = "3")]
    pub current_host_cpu_usage: f32,
    /// System used memory as a float in the range \[0.0, 1.0\] where 1.0 is defined as
    /// all available memory on the host is used.
    #[prost(float, tag = "4")]
    pub current_host_mem_usage: f32,
}
/// Worker info message, contains information about the worker and its current state.
/// All information is provided by the worker itself.
/// (-- api-linter: core::0140::prepositions=disabled
///      aip.dev/not-precedent: Removing those words make names less clear. --)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerHeartbeat {
    /// Worker identifier, should be unique for the namespace.
    /// It is distinct from worker identity, which is not necessarily namespace-unique.
    #[prost(string, tag = "1")]
    pub worker_instance_key: ::prost::alloc::string::String,
    /// Worker identity, set by the client, may not be unique.
    /// Usually host_name+(user group name)+process_id, but can be overwritten by the user.
    #[prost(string, tag = "2")]
    pub worker_identity: ::prost::alloc::string::String,
    /// Worker host information.
    #[prost(message, optional, tag = "3")]
    pub host_info: ::core::option::Option<WorkerHostInfo>,
    /// Task queue this worker is polling for tasks.
    #[prost(string, tag = "4")]
    pub task_queue: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub deployment_version: ::core::option::Option<
        super::super::deployment::v1::WorkerDeploymentVersion,
    >,
    #[prost(string, tag = "6")]
    pub sdk_name: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub sdk_version: ::prost::alloc::string::String,
    /// Worker status. Defined by SDK.
    #[prost(enumeration = "super::super::enums::v1::WorkerStatus", tag = "8")]
    pub status: i32,
    /// Worker start time.
    /// It can be used to determine worker uptime. (current time - start time)
    #[prost(message, optional, tag = "9")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Timestamp of this heartbeat, coming from the worker. Worker should set it to "now".
    /// Note that this timestamp comes directly from the worker and is subject to workers' clock skew.
    #[prost(message, optional, tag = "10")]
    pub heartbeat_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Elapsed time since the last heartbeat from the worker.
    #[prost(message, optional, tag = "11")]
    pub elapsed_since_last_heartbeat: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "12")]
    pub workflow_task_slots_info: ::core::option::Option<WorkerSlotsInfo>,
    #[prost(message, optional, tag = "13")]
    pub activity_task_slots_info: ::core::option::Option<WorkerSlotsInfo>,
    #[prost(message, optional, tag = "14")]
    pub nexus_task_slots_info: ::core::option::Option<WorkerSlotsInfo>,
    #[prost(message, optional, tag = "15")]
    pub local_activity_slots_info: ::core::option::Option<WorkerSlotsInfo>,
    #[prost(message, optional, tag = "16")]
    pub workflow_poller_info: ::core::option::Option<WorkerPollerInfo>,
    #[prost(message, optional, tag = "17")]
    pub workflow_sticky_poller_info: ::core::option::Option<WorkerPollerInfo>,
    #[prost(message, optional, tag = "18")]
    pub activity_poller_info: ::core::option::Option<WorkerPollerInfo>,
    #[prost(message, optional, tag = "19")]
    pub nexus_poller_info: ::core::option::Option<WorkerPollerInfo>,
    /// A Workflow Task found a cached Workflow Execution to run against.
    #[prost(int32, tag = "20")]
    pub total_sticky_cache_hit: i32,
    /// A Workflow Task did not find a cached Workflow execution to run against.
    #[prost(int32, tag = "21")]
    pub total_sticky_cache_miss: i32,
    /// Current cache size, expressed in number of Workflow Executions.
    #[prost(int32, tag = "22")]
    pub current_sticky_cache_size: i32,
    /// Plugins currently in use by this SDK.
    #[prost(message, repeated, tag = "23")]
    pub plugins: ::prost::alloc::vec::Vec<PluginInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerInfo {
    #[prost(message, optional, tag = "1")]
    pub worker_heartbeat: ::core::option::Option<WorkerHeartbeat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluginInfo {
    /// The name of the plugin, required.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The version of the plugin, may be empty.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
